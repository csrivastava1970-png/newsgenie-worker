console.log("[NG_BOOT_SIG] src/index.js 20260119_162645");
// src/index.js  (BOOT v3: echo + openai mode)
// Root if (path === "/" && request.method === "GET") {   return new globalThis.Response("OK", { status: 200, headers: corsHeaders(request) }); } 
// Uses OpenAI Responses API + Structured Outputs (json_schema)

const ENTRY_MARKER = "BOOTv3-src-indexjs-openai";

function json(data, status = 200, extraHeaders = {}) {
  return new globalThis.Response(JSON.stringify(data, null, 2), {
    status,
    headers: {
      "content-type": "application/json; charset=utf-8",
      ...extraHeaders,
    },
  });
}

function corsHeaders(req) {
  const origin = req.headers.get("Origin") || "*";
  return {
    "Access-Control-Allow-Origin": origin,
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Max-Age": "86400",
  };
}

async function readJson(req) {
  const txt = await req.clone().text();
  if (!txt) return {};
  const clean = txt.replace(/^\uFEFF/, ""); // ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ strip UTF-8 BOM
  try { return JSON.parse(clean); } catch { return { _raw: txt }; }
}


function safeParsePrompt(body) {
  // Accept:
  // 1) { prompt: "{...json...}" }
  // 2) { prompt: {...} }
  // 3) {...} (already the prompt object)
  let p = (body && typeof body === "object" && typeof body.story === "string" && body.story.trim()) ? body : (body?.prompt ?? body ?? {});
  if (typeof p === "string") {
    try { return JSON.parse(p); } catch { return { text: p }; }
  }
  return (p && typeof p === "object") ? p : { text: String(p ?? "") };
}

function extractOutputText(respJson) {
  // Response object example shows:
  // output[0].content[0].type === "output_text" and has "text"
  const out = respJson?.output || [];
  for (const item of out) {
    if (item?.type === "message" && item?.role === "assistant") {
      const content = item?.content || [];
      for (const c of content) {
        if (c?.type === "output_text" && typeof c?.text === "string") return c.text;
      }
    }
  }
  return null;
}

async function withTimeout(promise, ms, label = "timeout") {
  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(label), ms);
  try {
    return await promise(ac.signal);
  } finally {
    clearTimeout(t);
  }
}
// --- Durable Object: persistent store for /api/bytes/latest ---
export class BytesStore {
  constructor(state, env) {
    this.state = state;
    this.env = env;
  }

  async fetch(request) {
    const url = new URL(request.url);
    const method = request.method.toUpperCase();

    // We only care about /api/bytes/latest (but safe even if forwarded differently)
    if (method === "GET") {
      const latest = (await this.state.storage.get("latest")) ?? null;
      const bytes = latest?.bytes ?? null;
      return new Response(
        JSON.stringify({ ok: true, latest, bytes, ts: new Date().toISOString() }),
        { headers: { "content-type": "application/json" } }
      );
    }

    if (method === "POST") {
      const body = await request.json().catch(() => null);
      // Normalize: allow either {bytes:[...]} or full payload
      const latest = body && typeof body === "object"
        ? body
        : { bytes: null, source: "invalid_body", ts: new Date().toISOString() };

      await this.state.storage.put("latest", latest);
      const bytes = latest?.bytes ?? null;

      return new Response(
        JSON.stringify({ ok: true, latest, bytes, ts: new Date().toISOString() }),
        { headers: { "content-type": "application/json" } }
      );
    }

    return new Response("Method Not Allowed", { status: 405 });
  }
}
// --- end BytesStore ---

export default {
  async fetch(request, env, ctx) {
    /* NG_HEALTH_ROUTE_V1 20260119_162140 */
    try {
      const __u = new URL(request.url);
      if (__u.pathname === "/health" || __u.pathname === "/api/health" || __u.pathname === "/api/health/") {
        return new Response(JSON.stringify({ ok: true, ts: new Date().toISOString(), entry: 'src/index.js' }), { status: 200, headers: { 'content-type': 'application/json; charset=utf-8' } });
      }
      if (__u.pathname === '/') {
        return new Response('OK', { status: 200, headers: { 'content-type': 'text/plain; charset=utf-8' } });
      }
    } catch (e) { /* ignore */ }

    const url = new URL(request.url);
    const path = url.pathname;
const __NG_GEN_JS_B64__ = "77u/LyogPT09IE5HX0dFTkVSQVRFX1BFUk1fU0FGRV9WMV9TVEFSVCAoMjAyNjAyMDEpID09PQogICAtIEVuYWJsZXMgI2J0bkdlbmVyYXRlIGlmIGRpc2FibGVkCiAgIC0gQ2FwdHVyZXMgY2xpY2sgKHByZXZlbnRzIHJlbG9hZC9zdWJtaXQpCiAgIC0gUE9TVCAvYXBpL2RpZ2ktcGFjayAoc2luZ2xlIGluLWZsaWdodCkKICAgLSBTaG93cyByZXNwb25zZSBpbiBncmVlbiBiYW5uZXIKPT09ICovCihmdW5jdGlvbigpewogIGlmICh3aW5kb3cuX19OR19HRU5FUkFURV9QRVJNX1NBRkVfVjFfXykgcmV0dXJuOwogIHdpbmRvdy5fX05HX0dFTkVSQVRFX1BFUk1fU0FGRV9WMV9fID0gdHJ1ZTsKCiAgZnVuY3Rpb24gZW5zdXJlQmFubmVyKCl7CiAgICB2YXIgYiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJuZy1kZWJ1Zy1iYW5uZXIiKTsKICAgIGlmICghYil7CiAgICAgIGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKICAgICAgYi5pZCA9ICJuZy1kZWJ1Zy1iYW5uZXIiOwogICAgICBiLnN0eWxlLmNzc1RleHQgPQogICAgICAgICJwb3NpdGlvbjpmaXhlZDtsZWZ0OjhweDt0b3A6OHB4O3otaW5kZXg6OTk5OTk5OyIgKwogICAgICAgICJiYWNrZ3JvdW5kOiMxMTE7Y29sb3I6IzBmMDtwYWRkaW5nOjhweCAxMHB4O2JvcmRlci1yYWRpdXM6NnB4O2Rpc3BsYXk6bm9uZTsiICsKICAgICAgICAiZm9udDoxMnB4LzEuNCBtb25vc3BhY2U7bWF4LXdpZHRoOjg1dnc7d2hpdGUtc3BhY2U6cHJlLXdyYXA7IjsKICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYik7CiAgICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigiRE9NQ29udGVudExvYWRlZCIsIGZ1bmN0aW9uKCl7IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYik7IH0sIHsgb25jZTp0cnVlIH0pOwogICAgfQogICAgcmV0dXJuIGI7CiAgfQogIHZhciBfX05HX0JBTk5FUl9ERUJVRyA9IGZhbHNlOwp0cnkgeyBfX05HX0JBTk5FUl9ERUJVRyA9IChuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkuZ2V0KCJkZWJ1ZyIpID09PSAiMSIpOyB9IGNhdGNoKGUpIHt9CgpmdW5jdGlvbiBzZXRCYW5uZXIodCl7CiAgdHJ5IHsKICAgIHQgPSAodCA9PSBudWxsID8gIiIgOiBTdHJpbmcodCkpOwoKICAgIC8vIGtlZXAgb2xkIGZpbHRlciBiZWhhdmlvciAob25seSBzaG93IGVycm9ycyB1bmxlc3MgZGVidWc9MSkKICAgIGlmICghX19OR19CQU5ORVJfREVCVUcpIHsKICAgICAgdmFyIGlzRXJyID0gL0VSUk9SfG9rPWZhbHNlfG5vbi1KU09OfFBBWUxPQUQgRVJST1J8Q09QWSBmYWlsZWR8YnRuR2VuZXJhdGUgbm90IGZvdW5kL2kudGVzdCh0KTsKICAgICAgaWYgKCFpc0VycikgdCA9ICIiOwogICAgfQoKICAgIC8vIFZpc2libGUgc3RhdHVzIGxpbmUgKG5vIGZsb2F0aW5nIGJhbm5lciBuZWVkZWQpCiAgICB2YXIgZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VuU3RhdHVzIik7CiAgICBpZiAoZ3MpIGdzLnRleHRDb250ZW50ID0gdDsKCiAgICAvLyBJZiBvbGQgYmFubmVyIHN0aWxsIGV4aXN0cywgdXBkYXRlIGl0IHNpbGVudGx5IChkbyBub3QgZm9yY2Utc2hvdykKICAgIHRyeXsKICAgICAgdmFyIGIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmctZGVidWctYmFubmVyIik7CiAgICAgIGlmIChiKSBiLnRleHRDb250ZW50ID0gdDsKICAgIH1jYXRjaChlKXt9CiAgfSBjYXRjaChlKSB7fQp9CgogIC8vIHByZXZlbnQgZm9ybSBzdWJtaXQgbmF2aWdhdGlvbiAoY29tbW9uIGNhdXNlIG9mIHJlbG9hZCkKICBpZiAoIXdpbmRvdy5fX05HX0JMT0NLX1NVQk1JVF9TQUZFX1YxX18pewogICAgd2luZG93Ll9fTkdfQkxPQ0tfU1VCTUlUX1NBRkVfVjFfXyA9IHRydWU7CiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJzdWJtaXQiLCBmdW5jdGlvbihlKXsKICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBlLnN0b3BQcm9wYWdhdGlvbigpOwogICAgICBzZXRCYW5uZXIoIltOR10gc3VibWl0IHByZXZlbnRlZCIpOwogICAgfSwgdHJ1ZSk7CiAgfQoKICBmdW5jdGlvbiBxcyhzZWwpeyB0cnkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpOyB9IGNhdGNoKGUpeyByZXR1cm4gbnVsbDsgfSB9CgogIGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZCgpewogICAgZnVuY3Rpb24gdihpZCl7CiAgICAgIHRyeSB7IHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTsgcmV0dXJuIGVsID8gKGVsLnZhbHVlIHx8ICIiKS50cmltKCkgOiAiIjsgfQogICAgICBjYXRjaChlKXsgcmV0dXJuICIiOyB9CiAgICB9CgogICAgdmFyIHRvcGljID0gdigidG9waWMiKTsKICAgIHZhciBwbGF0Zm9ybSA9IHYoInBsYXRmb3JtIikgfHwgIkRpZ2l0YWwiOwogICAgdmFyIGFuZ2xlID0gdigiYW5nbGUiKTsKICAgIHZhciBzdG9yeV90eXBlID0gdigic3RvcnlUeXBlIikgfHwgImV4cGxhaW5lciI7CiAgICB2YXIgd2hhdF9oYXBwZW5lZCA9IHYoIndoYXRIYXBwZW5lZCIpOwogICAgdmFyIHNvdXJjZXMgPSB2KCJzb3VyY2VzIik7CiAgICB2YXIgYmFja2dyb3VuZCA9IHYoImJhY2tncm91bmQiKTsKCiAgICAvLyBSRVFVSVJFRCBieSBzZXJ2ZXIKICAgIHZhciBzdG9yeSA9IFsKICAgICAgdG9waWMgPyAoIlRPUElDOiAiICsgdG9waWMpIDogIiIsCiAgICAgIHN0b3J5X3R5cGUgPyAoIlNUT1JZX1RZUEU6ICIgKyBzdG9yeV90eXBlKSA6ICIiLAogICAgICBwbGF0Zm9ybSA/ICgiUExBVEZPUk06ICIgKyBwbGF0Zm9ybSkgOiAiIiwKICAgICAgYW5nbGUgPyAoIkFOR0xFOiAiICsgYW5nbGUpIDogIiIsCiAgICAgIHdoYXRfaGFwcGVuZWQgPyAoIldIQVRfSEFQUEVORUQ6XG4iICsgd2hhdF9oYXBwZW5lZCkgOiAiIiwKICAgICAgc291cmNlcyA/ICgiU09VUkNFUzpcbiIgKyBzb3VyY2VzKSA6ICIiLAogICAgICBiYWNrZ3JvdW5kID8gKCJCQUNLR1JPVU5EOlxuIiArIGJhY2tncm91bmQpIDogIiIKICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oIlxuXG4iKS50cmltKCk7CgogICAgcmV0dXJuIHsKICAgICAgc3Rvcnk6IHN0b3J5LAogICAgICB0b3BpYzogdG9waWMsCiAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybSwKICAgICAgYW5nbGU6IGFuZ2xlLAogICAgICBzdG9yeV90eXBlOiBzdG9yeV90eXBlLAogICAgICB3aGF0X2hhcHBlbmVkOiB3aGF0X2hhcHBlbmVkLAogICAgICBzb3VyY2VzOiBzb3VyY2VzLAogICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kCiAgICB9OwogIH0KCiAgdmFyIGluRmxpZ2h0ID0gZmFsc2U7CgovKiA9PT0gTkdfQVVUT1NDUk9MTF9OR1FVSUNLX1YxX1NUQVJUICgyMDI2MDIwMikgPT09ICovCmZ1bmN0aW9uIG5nQXV0b0ZvY3VzT3V0cHV0KCl7CiAgdHJ5ewogICAgdmFyIHEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmdRdWljayIpOwogICAgaWYgKCFxKSByZXR1cm4gZmFsc2U7CiAgICAvLyAobm8gYXV0by1zY3JvbGwgaGVyZTsgU3RvcnkgVmlldyBpcyB0aGUgcHJpbWFyeSB0YXJnZXQgbm93KQovLyBzb2Z0IG51ZGdlOiBhZGQgYSBjbGFzcyBicmllZmx5IChDU1MgY2FuIHN0eWxlIGl0IGlmIG5lZWRlZCkKcS5jbGFzc0xpc3QuYWRkKCJuZy1zb2Z0LW51ZGdlIik7CnNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdHJ5eyBxLmNsYXNzTGlzdC5yZW1vdmUoIm5nLXNvZnQtbnVkZ2UiKTsgfWNhdGNoKGUpe30gfSwgNjAwKTsKCiAgICByZXR1cm4gdHJ1ZTsKICB9Y2F0Y2goZSl7IHJldHVybiBmYWxzZTsgfQp9Ci8qID09PSBOR19BVVRPU0NST0xMX05HUVVJQ0tfVjFfRU5EID09PSAqLwoKCiAgZnVuY3Rpb24gd2lyZSgpewogICAgdmFyIGJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJidG5HZW5lcmF0ZSIpOwogICAgaWYgKCFidG4pewogICAgICBzZXRCYW5uZXIoIltOR10gYnRuR2VuZXJhdGUgbm90IGZvdW5kIChyZXRyeWluZykuLi4iKTsKICAgICAgc2V0VGltZW91dCh3aXJlLCA4MDApOwogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gZm9yY2UtZW5hYmxlCiAgICBidG4uZGlzYWJsZWQgPSBmYWxzZTsKICAgIGJ0bi5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik7CgogICAgaWYgKGJ0bi5fX25nUGVybVNhZmVXaXJlZCkgeyBzZXRCYW5uZXIoIltOR10gR2VuZXJhdGUgcmVhZHkuIik7IHJldHVybjsgfQogICAgYnRuLl9fbmdQZXJtU2FmZVdpcmVkID0gdHJ1ZTsKCiAgICAKLyogPT09IE5HX0RJR0lQQUNLX0NPUFlWSUVXX1YxX1NUQVJUICgyMDI2MDIwMikgPT09ICovCiAgICB2YXIgcHJlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nUmVzcG9uc2UiKTsKICAgIHZhciBxdWljayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJuZ1F1aWNrIik7CmZ1bmN0aW9uIE5HX3NldFF1aWNrU3VtbWFyeSh0ZXh0KSB7CiAgdHJ5IHsKICAgIHZhciBxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nUXVpY2siKTsKICAgIGlmICghcSkgcmV0dXJuOwogICAgdmFyIHQgPSAodGV4dCA9PSBudWxsID8gIiIgOiBTdHJpbmcodGV4dCkpLnRyaW0oKTsKICAgIC8vIHN1bW1hcnktb25seToga2VlcCBpdCBzaG9ydAogICAgaWYgKHQubGVuZ3RoID4gNTAwKSB0ID0gdC5zbGljZSgwLCA1MDApICsgIiDigKYiOwogICAgcS50ZXh0Q29udGVudCA9IHQgfHwgIihubyBxdWljayB2aWV3KSI7CiAgfSBjYXRjaCAoZSkge30KfQoKICAgIHZhciBidG5Db3B5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImJ0bkNvcHlEaWdpUGFjayIpOwogICAgdmFyIGJ0blZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiYnRuVmlld0RpZ2lQYWNrIik7CgogICAgZnVuY3Rpb24gbmdTYWZlU3RyKHgpeyB0cnkgeyByZXR1cm4gKHg9PW51bGwgPyAiIiA6IFN0cmluZyh4KSk7IH0gY2F0Y2goZSl7IHJldHVybiAiIjsgfSB9CgogICAgZnVuY3Rpb24gbmdBc09iaih2KXsKICAgICAgaWYgKCF2KSByZXR1cm4gbnVsbDsKICAgICAgaWYgKHR5cGVvZiB2ID09PSAib2JqZWN0IikgcmV0dXJuIHY7CiAgICAgIGlmICh0eXBlb2YgdiA9PT0gInN0cmluZyIpewogICAgICAgIHRyeSB7IHJldHVybiBKU09OLnBhcnNlKHYpOyB9IGNhdGNoKGUpeyByZXR1cm4gbnVsbDsgfQogICAgICB9CiAgICAgIHJldHVybiBudWxsOwogICAgfQoKICAgIGZ1bmN0aW9uIG5nUmVuZGVyUXVpY2sob3V0ail7CiAgdHJ5ewogICAgaWYgKCFvdXRqKSByZXR1cm4gIlN0YXR1czogKG5vIHF1aWNrIHZpZXcpIjsKICAgIGZ1bmN0aW9uIHMoeCl7IHJldHVybiAoeD09bnVsbCkgPyAiIiA6IFN0cmluZyh4KTsgfQogICAgZnVuY3Rpb24gY2xpcCh4LG4peyB4PXMoeCkudHJpbSgpOyByZXR1cm4geC5sZW5ndGg+biA/ICh4LnNsaWNlKDAsbi0xKSArICLigKYiKSA6IHg7IH0KICAgIHZhciBoZWFkbGluZSA9CiAgICAgIG91dGouaGVhZGxpbmUgfHwgb3V0ai5IZWFkbGluZSB8fCBvdXRqLnRpdGxlIHx8IG91dGouVGl0bGUgfHwKICAgICAgKG91dGoudG9wX2JhbmQgJiYgb3V0ai50b3BfYmFuZC5oZWFkbGluZSkgfHwgIiI7CiAgICB2YXIgc3VtbWFyeSA9CiAgICAgIG91dGouc3VtbWFyeSB8fCBvdXRqLlN1bW1hcnkgfHwgb3V0ai5icmllZiB8fCBvdXRqLm92ZXJ2aWV3IHx8ICIiOwogICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdXRqIHx8IHt9KTsKICAgIGZ1bmN0aW9uIGhhc0FueShzdWJzdHIpewogICAgICBzdWJzdHIgPSBzdWJzdHIudG9Mb3dlckNhc2UoKTsKICAgICAgcmV0dXJuIGtleXMuc29tZShrID0+IGsudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzdWJzdHIpKTsKICAgIH0KICAgIHZhciBmb3JtYXRzID0gW107CiAgICBpZiAoaGFzQW55KCJ3ZWIiKSkgZm9ybWF0cy5wdXNoKCJXZWIiKTsKICAgIGlmIChoYXNBbnkoInZpZGVvIikpIGZvcm1hdHMucHVzaCgiVmlkZW8iKTsKICAgIGlmIChoYXNBbnkoInlvdXR1YmUiKSB8fCBoYXNBbnkoInl0IikpIGZvcm1hdHMucHVzaCgiWW91VHViZSIpOwogICAgaWYgKGhhc0FueSgic2hvcnQiKSB8fCBoYXNBbnkoInJlZWwiKSkgZm9ybWF0cy5wdXNoKCJTaG9ydHMiKTsKICAgIGlmIChoYXNBbnkoInNvY2lhbCIpKSBmb3JtYXRzLnB1c2goIlNvY2lhbCIpOwogICAgaWYgKGhhc0FueSgiZ2Z4IikgfHwgaGFzQW55KCJncmFwaGljIikpIGZvcm1hdHMucHVzaCgiR3JhcGhpY3MiKTsKICAgIGlmIChoYXNBbnkoInJlZiIpIHx8IGhhc0FueSgic291cmNlIikpIGZvcm1hdHMucHVzaCgiUmVmcyIpOwogICAgdmFyIGxpbmVzID0gW107CiAgICBpZiAoaGVhZGxpbmUpIGxpbmVzLnB1c2goIkhlYWRsaW5lOiAiICsgY2xpcChoZWFkbGluZSwgMTEwKSk7CiAgICBpZiAoc3VtbWFyeSkgIGxpbmVzLnB1c2goIlN1bW1hcnk6ICAiICsgY2xpcChzdW1tYXJ5LCAxODApKTsKICAgIGxpbmVzLnB1c2goIkZvcm1hdHM6ICAiICsgKGZvcm1hdHMubGVuZ3RoID8gZm9ybWF0cy5qb2luKCIsICIpIDogIihzZWUgU3RvcnkgVmlldykiKSk7CiAgICBsaW5lcy5wdXNoKCJTdGF0dXM6ICAgT0siKTsKCgoKCi8vIC0tLSBFY2hvIHF1aWNrIHN1bW1hcnkgKHBheWxvYWQtYmFzZWQpIC0tLQp0cnkgewogIGlmIChvdXRqKSB7CiAKICAgIHZhciB0ID0gKG91dGoudG9waWMgfHwgIiIpLnRyaW0oKTsKICAgIHZhciB3ID0gKG91dGoud2hhdF9oYXBwZW5lZCB8fCAiIikudHJpbSgpOwppZiAoIXcpIHcgPSAob3V0ai5zdG9yeSB8fCAiIikudHJpbSgpOwppZiAodyAmJiB3LnN0YXJ0c1dpdGgoIlRPUElDOiIpKSB3ID0gdy5yZXBsYWNlKC9eVE9QSUM6W15cbl0qXG4qL2ksICIiKS50cmltKCk7CncgPSB3LnJlcGxhY2UoL15TVE9SWV9UWVBFOlteXG5dKlxuKi9nbWksICIiKS5yZXBsYWNlKC9eUExBVEZPUk06W15cbl0qXG4qL2dtaSwgIiIpLnRyaW0oKTsKCgogICAgdmFyIHN0ID0gKG91dGouc3RvcnlfdHlwZSB8fCAiIikudHJpbSgpOwogICAgdmFyIHBmID0gKG91dGoucGxhdGZvcm0gfHwgIiIpLnRyaW0oKTsKICAgIHZhciBzYyA9IChvdXRqLnNvdXJjZXMgfHwgIiIpLnRyaW0oKTsKCiAgICBsaW5lcy5wdXNoKCIiKTsgLy8gc3BhY2VyCiAgICBsaW5lcy5wdXNoKCJUb3BpYzogICAiICsgKHQgfHwgIihibGFuaykiKSk7CiAgICBsaW5lcy5wdXNoKCJXaGF0OiAgICAiICsgKHcgPyAody5zbGljZSgwLDE0MCkgKyAody5sZW5ndGg+MTQwID8gIuKApiIgOiAiIikpIDogIihibGFuaykiKSk7CiAgICBsaW5lcy5wdXNoKCJNZXRhOiAgICAiICsgIlR5cGU9IiArIChzdCB8fCAiLSIpICsgIiB8IFBsYXRmb3JtPSIgKyAocGYgfHwgIi0iKSArICIgfCBTb3VyY2VzQ2hhcnM9IiArIChzYyA/IHNjLmxlbmd0aCA6IDApKTsKICB9Cn0gY2F0Y2goZSkge30KCiAgICByZXR1cm4gbGluZXMuam9pbigiXG4iKTsKICB9Y2F0Y2goZSl7CiAgICByZXR1cm4gIlN0YXR1czogKHF1aWNrIHZpZXcgc3VtbWFyeSBmYWlsZWQpIjsKICB9Cn0KCiAgICAKCiAgICBmdW5jdGlvbiBuZ1NldENvcHlWaWV3RW5hYmxlZChvbil7CiAgICAgIGlmIChidG5Db3B5KSBidG5Db3B5LmRpc2FibGVkID0gIW9uOwogICAgICBpZiAoYnRuVmlldykgYnRuVmlldy5kaXNhYmxlZCA9ICFvbjsKICAgIH0KCiAgICBmdW5jdGlvbiBuZ0NvcHlUb0NsaXBib2FyZCh0eHQpewogICAgICB0eHQgPSBuZ1NhZmVTdHIodHh0KTsKICAgICAgaWYgKCF0eHQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIk5vdGhpbmcgdG8gY29weSIpKTsKICAgICAgaWYgKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuY2xpcGJvYXJkICYmIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KSB7CiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHR4dCk7CiAgICAgIH0KICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7CiAgICAgICAgdHJ5ewogICAgICAgICAgdmFyIHRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTsKICAgICAgICAgIHRhLnZhbHVlID0gdHh0OwogICAgICAgICAgdGEuc2V0QXR0cmlidXRlKCJyZWFkb25seSIsInJlYWRvbmx5Iik7CiAgICAgICAgICB0YS5zdHlsZS5wb3NpdGlvbiA9ICJmaXhlZCI7CiAgICAgICAgICB0YS5zdHlsZS5sZWZ0ID0gIi05OTk5cHgiOwogICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0YSk7CiAgICAgICAgICB0YS5zZWxlY3QoKTsKICAgICAgICAgIHZhciBvayA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCJjb3B5Iik7CiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhKTsKICAgICAgICAgIGlmIChvaykgcmVzb2x2ZSgpOwogICAgICAgICAgZWxzZSByZWplY3QobmV3IEVycm9yKCJleGVjQ29tbWFuZChjb3B5KSBmYWlsZWQiKSk7CiAgICAgICAgfSBjYXRjaChlKXsgcmVqZWN0KGUpOyB9CiAgICAgIH0pOwogICAgfQoKICAgIC8vIHdpcmUgQ09QWS9WSUVXIG9uY2UKICAgIGlmIChidG5Db3B5ICYmICFidG5Db3B5Ll9fbmdXaXJlZCl7CiAgICAgIGJ0bkNvcHkuX19uZ1dpcmVkID0gdHJ1ZTsKICAgICAgICAgICAgYnRuQ29weS5hZGRFdmVudExpc3RlbmVyKCJjbGljayIsIGZ1bmN0aW9uKGUpewogICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wUHJvcGFnYXRpb24oKTsKICAgICAgICB2YXIgaiA9IHdpbmRvdy5fX05HX0xBU1RfRElHSVBBQ0sgfHwgbnVsbDsKICAgICAgICB2YXIgd2FudEpzb24gPSAhIShlICYmIGUuc2hpZnRLZXkpOwogICAgICAgIHZhciB0eHQgPSB3YW50SnNvbgogICAgICAgICAgPyAoKGogJiYgai5vdXRwdXRfanNvbikgPyBKU09OLnN0cmluZ2lmeShqLm91dHB1dF9qc29uLCBudWxsLCAyKSA6ICIiKQogICAgICAgICAgOiAoKGogJiYgai5jb3B5X3RleHQpID8gbmdTYWZlU3RyKGouY29weV90ZXh0KSA6IChqID8gSlNPTi5zdHJpbmdpZnkoaiwgbnVsbCwgMikgOiAiIikpOwogICAgICAgIGlmICh3YW50SnNvbiAmJiAhdHh0KSB7IHNldEJhbm5lcigiW05HXSBObyBvdXRwdXRfanNvbiB5ZXQuIEdlbmVyYXRlIGZpcnN0LiIpOyByZXR1cm47IH0KCiAgICAgICAgbmdDb3B5VG9DbGlwYm9hcmQodHh0KQogICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKXsKICAgICAgICAgICAgc2V0QmFubmVyKCJbTkddIENvcGllZCBESUdJX1BBQ0sgdG8gY2xpcGJvYXJkLiIpOwogICAgICAgICAgfSkKICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpewogICAgICAgICAgICBzZXRCYW5uZXIoIltOR10gQ09QWSBmYWlsZWQ6ICIgKyAoZXJyICYmIGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKSkpOwogICAgICAgICAgfSk7CiAgICAgIH0sIHRydWUpOwoKICAgIH0KCiAgICBpZiAoYnRuVmlldyAmJiAhYnRuVmlldy5fX25nV2lyZWQpewogICAgICBidG5WaWV3Ll9fbmdXaXJlZCA9IHRydWU7CiAgICAgIGJ0blZpZXcuYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBmdW5jdGlvbihlKXsKICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcFByb3BhZ2F0aW9uKCk7CiAgICAgICAgdmFyIGogPSB3aW5kb3cuX19OR19MQVNUX0RJR0lQQUNLIHx8IG51bGw7CiAgICAgICAgdmFyIG91dGogPSAoaiAmJiBqLm91dHB1dF9qc29uKSA/IGoub3V0cHV0X2pzb24gOiBudWxsOwoKCgoKICAgICAgICAvLyBzZXRCYW5uZXIoIltOR10gUXVpY2sgVmlldyB1cGRhdGVkLiIpOyAvLyBub2lzeTogcXVpY2sgdmlldyBpcyBpbnRlcm5hbAoKICAgICAgfSwgdHJ1ZSk7CiAgICB9CgogICAgbmdTZXRDb3B5Vmlld0VuYWJsZWQoZmFsc2UpOwoKYnRuLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgZnVuY3Rpb24oZSl7CiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgZS5zdG9wUHJvcGFnYXRpb24oKTsKCiAgICAgIGlmIChpbkZsaWdodCl7CiAgICAgICAgc2V0QmFubmVyKCJbTkddIEFscmVhZHkgcnVubmluZ+KApiIpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBpbkZsaWdodCA9IHRydWU7CiAgICAgIGJ0bi5kaXNhYmxlZCA9IHRydWU7CgogICAgICBzZXRCYW5uZXIoIltOR10gUE9TVCAvYXBpL2RpZ2ktcGFjayAuLi4iKTsKCiAgICAgIHZhciBwYXlsb2FkID0gYnVpbGRQYXlsb2FkKCk7CgogICAgICAKICAgICAgdHJ5IHsKICAgICAgICB3aW5kb3cuX19OR19MQVNUX1BBWUxPQUQgPSBwYXlsb2FkOwogICAgICAgIHZhciBzbCA9IChwYXlsb2FkICYmIHBheWxvYWQuc3RvcnkpID8gU3RyaW5nKHBheWxvYWQuc3RvcnkpLmxlbmd0aCA6IDA7CiAgICAgICAgdmFyIHdsID0gKHBheWxvYWQgJiYgcGF5bG9hZC53aGF0X2hhcHBlbmVkKSA/IFN0cmluZyhwYXlsb2FkLndoYXRfaGFwcGVuZWQpLmxlbmd0aCA6IDA7CiAgICAgICAgdmFyIHNyY2wgPSAocGF5bG9hZCAmJiBwYXlsb2FkLnNvdXJjZXMpID8gU3RyaW5nKHBheWxvYWQuc291cmNlcykubGVuZ3RoIDogMDsKICAgICAgICBzZXRCYW5uZXIoIltOR10gcGF5bG9hZC5zdG9yeS5sZW49IiArIHNsICsgIiB3aGF0Lmxlbj0iICsgd2wgKyAiIHNvdXJjZXMubGVuPSIgKyBzcmNsKTsKICAgICAgIHZhciBoYXNUb3BpYyA9ICEhKHBheWxvYWQgJiYgcGF5bG9hZC50b3BpYyAmJiBTdHJpbmcocGF5bG9hZC50b3BpYykudHJpbSgpKTsKdmFyIGhhc1doYXQgID0gISEocGF5bG9hZCAmJiBwYXlsb2FkLndoYXRfaGFwcGVuZWQgJiYgU3RyaW5nKHBheWxvYWQud2hhdF9oYXBwZW5lZCkudHJpbSgpKTsKaWYgKCFoYXNUb3BpYyAmJiAhaGFzV2hhdCkgeyB0aHJvdyBuZXcgRXJyb3IoIlBsZWFzZSBmaWxsIFRvcGljIG9yIFdoYXQgSGFwcGVuZWQiKTsgfQoKICAgIH0gY2F0Y2goZSkgewogICAgICAgIHNldEJhbm5lcigiW05HXSBQQVlMT0FEIEVSUk9SOiAiICsgKGUgJiYgZS5tZXNzYWdlID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpKSk7CiAgICAgICAgaW5GbGlnaHQgPSBmYWxzZTsKICAgICAgICBidG4uZGlzYWJsZWQgPSBmYWxzZTsKICAgICAgICBidG4ucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOwogICAgICAgIHJldHVybjsKICAgICAgfQovLyA9PT0gTkdfUkVBTF9NT0RFX0dVQVJEX1YyX1NUQVJUICgyMDI2MDIwNCkgPT09CmNvbnN0IF9fcmVhbCA9IChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgiTkdfUkVBTF9NT0RFIikgfHwgIjAiKSA9PT0gIjEiOwoKLy8gSGFyZC1mb3JjZSBtb2RlIGludG8gcGF5bG9hZCAocHJldmVudHMgYWNjaWRlbnRhbCB0b2tlbiB1c2UpCmlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAib2JqZWN0IikgewogIGlmICghX19yZWFsKSB7CiAgICBwYXlsb2FkLm1vZGUgPSAiZWNobyI7CiAgICB0cnkgeyBzZXRCYW5uZXIoIlJlYWwgTW9kZSBPRkYg4oaSIGZvcmNlZCBFQ0hPIChubyB0b2tlbnMpLiIsICJvayIpOyB9IGNhdGNoKGUpe30KICB9IGVsc2UgewogICAgLy8gYWxsb3cgcmVhbCBtb2RlOyBpZiBtb2RlIG1pc3NpbmcsIHNldCBhIHNlbnNpYmxlIGRlZmF1bHQKICAgIGlmICghcGF5bG9hZC5tb2RlKSBwYXlsb2FkLm1vZGUgPSAib3BlbmFpIjsKICAgIHRyeSB7IHNldEJhbm5lcigiUmVhbCBNb2RlIE9OIOKGkiBhbGxvd2VkIE9QRU5BSSAoc21va2UgdGVzdCkuIiwgIm9rIik7IH0gY2F0Y2goZSl7fQogIH0KfQovLyA9PT0gTkdfUkVBTF9NT0RFX0dVQVJEX1YyX0VORCA9PT0KLy8gPT09IE5HX01PREVfU1RBVFVTX1YxX1NUQVJUICgyMDI2MDIwNCkgPT09CnRyeSB7CiB2YXIgZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmdTdGF0dXMiKSB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VuU3RhdHVzIik7CgogIGlmIChncykgeyB2YXIgYmFzZSA9IChncy5nZXRBdHRyaWJ1dGUoImRhdGEtYmFzZSIpIHx8IGdzLnRleHRDb250ZW50IHx8ICIiKTsgZ3Muc2V0QXR0cmlidXRlKCJkYXRhLWJhc2UiLCBiYXNlKTsgZ3MudGV4dENvbnRlbnQgPSAoYmFzZSA/IGJhc2UgKyAiIHwgIiA6ICIiKSArIChfX3JlYWwgPyAiUkVBTCIgOiAiRUNITyIpOyB9Cgp9IGNhdGNoKGUpIHt9Ci8vID09PSBOR19NT0RFX1NUQVRVU19WMV9FTkQgPT09CgovLyA9PT0gTkdfU1RBVFVTX0JBU0VfV09SS0lOR19WMl9TVEFSVCAoMjAyNjAyMDQpID09PQp0cnkgewogIHZhciBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nU3RhdHVzIik7CiAgaWYgKHMpIHsKICAgIHMuc2V0QXR0cmlidXRlKCJkYXRhLWJhc2UiLCAiV29ya2luZyIpOwogICAgcy50ZXh0Q29udGVudCA9ICJXb3JraW5nIHwgIiArIChfX3JlYWwgPyAiUkVBTCIgOiAiRUNITyIpOwogIH0KfSBjYXRjaChlKSB7fQovLyA9PT0gTkdfU1RBVFVTX0JBU0VfV09SS0lOR19WMl9FTkQgPT09CgoKCiAgICAgIGZldGNoKCIvYXBpL2RpZ2ktcGFjayIsIHsKCgoKICAgICAgICBtZXRob2Q6ICJQT1NUIiwKICAgICAgICBoZWFkZXJzOiB7ICJjb250ZW50LXR5cGUiOiAiYXBwbGljYXRpb24vanNvbiIgfSwKICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKQogICAgICB9KS50aGVuKGZ1bmN0aW9uKHIpewogICAgICAgIHJldHVybiByLnRleHQoKS50aGVuKGZ1bmN0aW9uKHRleHQpewogICAgICAgICAgdmFyIHBhcnNlZCA9IG51bGwsIHBhcnNlX29rID0gZmFsc2U7CiAgICAgICAgICB0cnkgeyBwYXJzZWQgPSBKU09OLnBhcnNlKHRleHQpOyBwYXJzZV9vayA9IHRydWU7IH0gY2F0Y2goZSkge30KCiAgICAgICAgICBpZiAoIXBhcnNlX29rKXsKICAgICAgICAgICAgaWYgKHByZSkgcHJlLnRleHRDb250ZW50ID0gdGV4dCB8fCAiKGVtcHR5IHJlc3BvbnNlKSI7CiAgICAgICAgICAgIE5HX3NldFF1aWNrU3VtbWFyeSgiKG5vIHF1aWNrIHZpZXcgLSByZXNwb25zZSB3YXMgbm90IEpTT04pIik7CgogICAgICAgICAgICB2YXIgZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VuU3RhdHVzIik7IGlmIChncykgZ3MudGV4dENvbnRlbnQgPSAiIjsKICAgICAgICAgICAgbmdTZXRDb3B5Vmlld0VuYWJsZWQoZmFsc2UpOwogICAgICAgICAgICBzZXRCYW5uZXIoIltOR10gc3RhdHVzPSIgKyByLnN0YXR1cyArICIgKG5vbi1KU09OKVxuIiArICh0ZXh0fHwiIikuc2xpY2UoMCwgNzAwKSk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KLy8gPT09IE5HX1NUQVRVU19CQVNFX09LX1YyX1NUQVJUICgyMDI2MDIwNCkgPT09CnRyeSB7CiAgdmFyIHMyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nU3RhdHVzIik7CiAgaWYgKHMyKSB7CiAgICBzMi5zZXRBdHRyaWJ1dGUoImRhdGEtYmFzZSIsICJPSyIpOwogICAgczIudGV4dENvbnRlbnQgPSAiT0sgfCAiICsgKF9fcmVhbCA/ICJSRUFMIiA6ICJFQ0hPIik7CiAgfQp9IGNhdGNoKGUpIHt9Ci8vID09PSBOR19TVEFUVVNfQkFTRV9PS19WMl9FTkQgPT09CgoKICAgICAgICAgIHdpbmRvdy5fX05HX0xBU1RfRElHSVBBQ0sgPSBwYXJzZWQ7CiAgICAgIAoKICAgICAgICAgIC8vIElmIHNlcnZlciBzYXlzIG9rOmZhbHNlIE9SIEhUVFAgPj0gNDAwLCB0cmVhdCBhcyBlcnJvciAoZG8gbm90IGVuYWJsZSBjb3B5L3ZpZXcpCiAgICAgICAgICB2YXIgc2VydmVyT2sgPSAocGFyc2VkICYmIHBhcnNlZC5vayA9PT0gdHJ1ZSkgJiYgKHIuc3RhdHVzID49IDIwMCAmJiByLnN0YXR1cyA8IDMwMCk7CiAgICAgICAgICBpZiAoIXNlcnZlck9rKXsKICAgICAgICAgICAgdmFyIGdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImdlblN0YXR1cyIpOyBpZiAoZ3MpIGdzLnRleHRDb250ZW50ID0gIiI7CiAgICAgICAgICAgIHZhciBlcnJNc2cgPSAocGFyc2VkICYmIHBhcnNlZC5lcnJvcikgPyBuZ1NhZmVTdHIocGFyc2VkLmVycm9yKSA6ICgiSFRUUCAiICsgci5zdGF0dXMpOwogICAgICAgICAgICBpZiAocHJlKSBwcmUudGV4dENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShwYXJzZWQsIG51bGwsIDIpOwogICAgICAgICAgICBOR19zZXRRdWlja1N1bW1hcnkoIlNlcnZlciBlcnJvcjogIiArIGVyck1zZyk7CgogICAgICAgICAgICBuZ1NldENvcHlWaWV3RW5hYmxlZChmYWxzZSk7CiAgICAgICAgICAgIHNldEJhbm5lcigiW05HXSBzdGF0dXM9IiArIHIuc3RhdHVzICsgIiBvaz1mYWxzZSIpOwp0cnl7IGlmICh0eXBlb2Ygd2luZG93Lk5HX3NldE91dHB1dFJlYWR5ID09PSAiZnVuY3Rpb24iKSB3aW5kb3cuTkdfc2V0T3V0cHV0UmVhZHkodHJ1ZSk7IH1jYXRjaChlKXt9CgogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIGNvcHlfdGV4dCA9IChwYXJzZWQgJiYgcGFyc2VkLmNvcHlfdGV4dCkgPyBuZ1NhZmVTdHIocGFyc2VkLmNvcHlfdGV4dCkgOiAiIjsKICAgICAgICAgIHZhciBvdXRqID0gKHBhcnNlZCAmJiBwYXJzZWQub3V0cHV0X2pzb24pID8gcGFyc2VkLm91dHB1dF9qc29uIDogKHBhcnNlZCAmJiBwYXJzZWQucmVjZWl2ZWQgPyBwYXJzZWQucmVjZWl2ZWQgOiBudWxsKTsKLy8gPT09IE5HX1FVSUNLX0VDSE9fU1VNTUFSWV9WMV9TVEFSVCAoMjAyNjAyMDQpID09PQp0cnkgewogIHZhciBpc0VjaG8gPSAocGFyc2VkICYmIHBhcnNlZC5tb2RlID09PSAiZWNobyIpIHx8IChvdXRqICYmIG91dGoubW9kZSA9PT0gImVjaG8iKTsKICBpZiAoaXNFY2hvICYmIG91dGopIHsKICAgIHZhciB0ID0gKG91dGoudG9waWMgfHwgIiIpLnRyaW0oKTsKICAgIHZhciB3ID0gKG91dGoud2hhdF9oYXBwZW5lZCB8fCAiIikudHJpbSgpOwogICAgdmFyIHN0ID0gKG91dGouc3RvcnlfdHlwZSB8fCAiIikudHJpbSgpOwogICAgdmFyIHBmID0gKG91dGoucGxhdGZvcm0gfHwgIiIpLnRyaW0oKTsKICAgIHZhciBzYyA9IChvdXRqLnNvdXJjZXMgfHwgIiIpLnRyaW0oKTsKICAgIHZhciBsaW5lMSA9ICh0ID8gKCJUb3BpYzogIiArIHQpIDogIlRvcGljOiAoYmxhbmspIik7CiAgICB2YXIgbGluZTIgPSAodyA/ICgiV2hhdDogIiArIHcuc2xpY2UoMCwgMTQwKSArICh3Lmxlbmd0aCA+IDE0MCA/ICLigKYiIDogIiIpKSA6ICJXaGF0OiAoYmxhbmspIik7CiAgICB2YXIgbWV0YSA9ICJUeXBlOiAiICsgKHN0IHx8ICItIikgKyAiIHwgUGxhdGZvcm06ICIgKyAocGYgfHwgIi0iKSArICIgfCBTb3VyY2VzIGNoYXJzOiAiICsgKHNjID8gc2MubGVuZ3RoIDogMCk7CiAgICBOR19zZXRRdWlja1N1bW1hcnkobGluZTEgKyAiXG4iICsgbGluZTIgKyAiXG4iICsgbWV0YSk7CiAgfQp9IGNhdGNoKGUpIHt9Ci8vID09PSBOR19RVUlDS19FQ0hPX1NVTU1BUllfVjFfRU5EID09PQoKCiAgICAgICAgICBpZiAocHJlKSBwcmUudGV4dENvbnRlbnQgPSAocGFyc2VkICYmIHBhcnNlZC5vdXRwdXRfanNvbikgPyBKU09OLnN0cmluZ2lmeShwYXJzZWQub3V0cHV0X2pzb24sIG51bGwsIDIpIDogSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTsKCiAgICAgICAgICB0cnl7CiAgY29uc3QgZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJuZy1xdWljay1kZXRhaWxzIik7CiAgaWYgKGQpIGQub3BlbiA9IHRydWU7Cn1jYXRjaChlKXt9CgoKCiAgICAgICAgICB2YXIgZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VuU3RhdHVzIik7IGlmIChncykgZ3MudGV4dENvbnRlbnQgPSAiVGlwOiBTaGlmdCtDbGljayBjb3BpZXMgSlNPTiI7CiAgICAgICAgICBuZ1NldENvcHlWaWV3RW5hYmxlZCh0cnVlKTsKICAgICAgICAgIHRyeXsKICAgICAgICAgICAgdmFyIF9jID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImJ0bkNvcHlEaWdpUGFjayIpOwogICAgICAgICAgICBpZiAoX2MpIF9jLmRpc2FibGVkID0gZmFsc2U7CiAgICAgICAgICB9Y2F0Y2goZSl7fQogICAgICAgIAoKICAgICAgICAgIHNldEJhbm5lcigiIik7CgogICAgICAgICAgLy8gLS0tIEF1dG8tb3BlbiBTdG9yeSBWaWV3IChwcmltYXJ5IE91dHB1dHMgSHViKSAtLS0KICAgICAgICAgIHRyeXsKICB0cnl7IGlmICh0eXBlb2Ygd2luZG93LnNldFRhYiA9PT0gImZ1bmN0aW9uIikgd2luZG93LnNldFRhYigic3RvcnkiKTsgfWNhdGNoKGUpe30KdHJ5ewogIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nLW91dHB1dC1oZWFkcm93Iik7CiAgaWYgKGhlYWQgJiYgaGVhZC5zY3JvbGxJbnRvVmlldykgaGVhZC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiJzbW9vdGgiLCBibG9jazoic3RhcnQiIH0pOwp9Y2F0Y2goZSl7fQoKdHJ5eyBpZiAodHlwZW9mIHdpbmRvdy5OR19zZXRPdXRwdXRSZWFkeSA9PT0gImZ1bmN0aW9uIikgd2luZG93Lk5HX3NldE91dHB1dFJlYWR5KHRydWUpOyB9Y2F0Y2goZSl7fQoKCiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgibmctc2hvdy1zdG9yeXZpZXciKTsKICAgICAgICAgICAgdmFyIHBhbmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm5nLXN0b3J5dmlldyIpOwogICAgICAgICAgICBpZiAocGFuZWwpIHBhbmVsLnN0eWxlLmRpc3BsYXkgPSAiYmxvY2siOwoKICAgICAgICAgICAgLy8gRGlyZWN0IGZpbGwgKE5PIHRvZ2dsZSBjbGljaykKICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuTkdfZmlsbFN0b3J5VmlldyA9PT0gImZ1bmN0aW9uIikgewovKiA9PT0gTkdfU1RPUllWSUVXX0ZPUk1BVFRFRF9SRU5ERVJfVjFfU1RBUlQgKDIwMjYwMjA1KSA9PT0gKi8KZnVuY3Rpb24gTkdfc2FmZVRpdGxlRnJvbUtleShrKXsKICB0cnl7CiAgICByZXR1cm4gU3RyaW5nKGsgfHwgIiIpCiAgICAgIC5yZXBsYWNlKC9bX1wtXSsvZywiICIpCiAgICAgIC5yZXBsYWNlKC9ccysvZywiICIpCiAgICAgIC50cmltKCkKICAgICAgLnJlcGxhY2UoL1xiXHcvZywgYyA9PiBjLnRvVXBwZXJDYXNlKCkpOwogIH1jYXRjaChlKXsgcmV0dXJuIFN0cmluZyhrfHwiRm9ybWF0Iik7IH0KfQoKZnVuY3Rpb24gTkdfY29weVRleHRUb0NsaXBib2FyZCh0ZXh0KXsKICBjb25zdCB0ID0gKHRleHQgPT0gbnVsbCkgPyAiIiA6IFN0cmluZyh0ZXh0KTsKICAvLyBtb2Rlcm4KICBpZiAobmF2aWdhdG9yLmNsaXBib2FyZCAmJiBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCkgewogICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHQpLmNhdGNoKCgpID0+IHsKICAgICAgLy8gZmFsbGJhY2sKICAgICAgY29uc3QgdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpOwogICAgICB0YS52YWx1ZSA9IHQ7CiAgICAgIHRhLnN0eWxlLnBvc2l0aW9uID0gImZpeGVkIjsKICAgICAgdGEuc3R5bGUubGVmdCA9ICItOTk5OXB4IjsKICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0YSk7CiAgICAgIHRhLmZvY3VzKCk7IHRhLnNlbGVjdCgpOwogICAgICB0cnkgeyBkb2N1bWVudC5leGVjQ29tbWFuZCgiY29weSIpOyB9IGNhdGNoKGUpe30KICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YSk7CiAgICB9KTsKICB9CiAgLy8gZmFsbGJhY2sKICBjb25zdCB0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIik7CiAgdGEudmFsdWUgPSB0OwogIHRhLnN0eWxlLnBvc2l0aW9uID0gImZpeGVkIjsKICB0YS5zdHlsZS5sZWZ0ID0gIi05OTk5cHgiOwogIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGEpOwogIHRhLmZvY3VzKCk7IHRhLnNlbGVjdCgpOwogIHRyeSB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKCJjb3B5Iik7IH0gY2F0Y2goZSl7fQogIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGEpOwogIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsKfQoKZnVuY3Rpb24gTkdfcGlja0RpZ2lQYWNrRm9ybWF0cyhkcCl7CiAgLy8gcmV0dXJucyBhcnJheSBvZiB7IGtleSwgdGl0bGUsIHRleHQgfQogIGNvbnN0IG91dCA9IFtdOwogIGlmICghZHApIHJldHVybiBvdXQ7CgogIC8vIENhc2UgQTogZHAuZm9ybWF0cyBpcyBhcnJheSBbe25hbWUvdGl0bGUva2V5LCBjb250ZW50L3RleHR9XQogIGlmIChBcnJheS5pc0FycmF5KGRwLmZvcm1hdHMpKSB7CiAgICBkcC5mb3JtYXRzLmZvckVhY2goKGl0LCBpZHgpID0+IHsKICAgICAgY29uc3Qga2V5ID0gaXQgJiYgKGl0LmtleSB8fCBpdC5uYW1lIHx8IGl0LnRpdGxlIHx8ICgiZm9ybWF0XyIraWR4KSk7CiAgICAgIGNvbnN0IHRpdGxlID0gaXQgJiYgKGl0LnRpdGxlIHx8IGl0Lm5hbWUgfHwgTkdfc2FmZVRpdGxlRnJvbUtleShrZXkpKTsKICAgICAgY29uc3QgdGV4dCA9IGl0ICYmIChpdC50ZXh0IHx8IGl0LmNvbnRlbnQgfHwgaXQuYm9keSB8fCAiIik7CiAgICAgIGlmIChTdHJpbmcodGV4dHx8IiIpLnRyaW0oKSkgb3V0LnB1c2goeyBrZXksIHRpdGxlLCB0ZXh0OiBTdHJpbmcodGV4dCkgfSk7CiAgICB9KTsKICAgIGlmIChvdXQubGVuZ3RoKSByZXR1cm4gb3V0OwogIH0KCiAgLy8gQ2FzZSBCOiBjb21tb24ga2V5cyBvbiBvYmplY3QKICBpZiAodHlwZW9mIGRwID09PSAib2JqZWN0IikgewogICAgY29uc3Qgc2tpcCA9IG5ldyBTZXQoWwogICAgICAib2siLCJ0cyIsIm1ldGEiLCJyZWZzIiwic291cmNlcyIsInNvdXJjZSIsIm1vZGVsIiwibW9kZSIsInN0YXR1cyIsImVycm9yIiwKICAgICAgInJhdyIsImpzb24iLCJkZWJ1ZyIsInRlbGVtZXRyeSIsIl9tZXRhIiwiX2RlYnVnIgogICAgXSk7CgogICAgLy8gcHJlZmVyIGtub3duIG9yZGVyIGlmIHByZXNlbnQKICAgIGNvbnN0IHByZWZlcnJlZCA9IFsKICAgICAgIndlYl9hcnRpY2xlIiwiYXJ0aWNsZSIsIm5ld3NfYXJ0aWNsZSIsCiAgICAgICJ2aWRlb19zY3JpcHQiLCJ2aWRlbyIsInR2X3NjcmlwdCIsCiAgICAgICJ5b3V0dWJlIiwieW91dHViZV9zY3JpcHQiLCJ5dF9zY3JpcHQiLAogICAgICAic2hvcnRzIiwicmVlbCIsInJlZWxzIiwiaW5zdGFfcmVlbCIsCiAgICAgICJzb2NpYWwiLCJzb2NpYWxfcG9zdHMiLCJ4X3RocmVhZCIsInR3aXR0ZXJfdGhyZWFkIiwKICAgICAgImhlYWRsaW5lIiwic3VtbWFyeSIsImJ1bGxldF9wb2ludHMiLCJhbmNob3JzIiwicHJvbXB0cyIKICAgIF07CgogICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRwKTsKICAgIGNvbnN0IG9yZGVyZWQgPSBbXTsKICAgIHByZWZlcnJlZC5mb3JFYWNoKGsgPT4geyBpZiAoa2V5cy5pbmNsdWRlcyhrKSkgb3JkZXJlZC5wdXNoKGspOyB9KTsKICAgIGtleXMuZm9yRWFjaChrID0+IHsgaWYgKCFvcmRlcmVkLmluY2x1ZGVzKGspKSBvcmRlcmVkLnB1c2goayk7IH0pOwoKICAgIG9yZGVyZWQuZm9yRWFjaCgoaykgPT4gewogICAgICBpZiAoc2tpcC5oYXMoaykpIHJldHVybjsKICAgICAgY29uc3QgdiA9IGRwW2tdOwogICAgICBpZiAodiA9PSBudWxsKSByZXR1cm47CgogICAgICAvLyBpZiBuZXN0ZWQgb2JqZWN0IHdpdGggdGV4dC1pc2gKICAgICAgaWYgKHR5cGVvZiB2ID09PSAib2JqZWN0IiAmJiAhQXJyYXkuaXNBcnJheSh2KSkgewogICAgICAgIGNvbnN0IG1heWJlID0gdi50ZXh0IHx8IHYuY29udGVudCB8fCB2LmJvZHkgfHwgdi5zY3JpcHQgfHwgdi5vdXRwdXQgfHwgIiI7CiAgICAgICAgaWYgKFN0cmluZyhtYXliZXx8IiIpLnRyaW0oKSkgewogICAgICAgICAgb3V0LnB1c2goeyBrZXk6IGssIHRpdGxlOiBOR19zYWZlVGl0bGVGcm9tS2V5KGspLCB0ZXh0OiBTdHJpbmcobWF5YmUpIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIC8vIHByaW1pdGl2ZXMgLyBhcnJheXMKICAgICAgY29uc3QgdGV4dCA9IEFycmF5LmlzQXJyYXkodikgPyB2LmpvaW4oIlxuIikgOiBTdHJpbmcodik7CiAgICAgIGlmICh0ZXh0LnRyaW0oKSkgb3V0LnB1c2goeyBrZXk6IGssIHRpdGxlOiBOR19zYWZlVGl0bGVGcm9tS2V5KGspLCB0ZXh0IH0pOwogICAgfSk7CiAgfQoKICByZXR1cm4gb3V0Owp9CgpmdW5jdGlvbiBOR19yZW5kZXJEaWdpUGFja0Zvcm1hdHRlZChkcCl7CiAgY29uc3QgaG9zdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJuZy1zdG9yeXZpZXctZm9ybWF0dGVkIik7CiAgaWYgKCFob3N0KSByZXR1cm4gZmFsc2U7CgogIGhvc3QuaW5uZXJIVE1MID0gIiI7CiAgLy8gLS0tLSB1bndyYXAgY29tbW9uIEFQSSB3cmFwcGVycyAoZWNoby9yZWFsKSAtLS0tCiAgdHJ5IHsKICAgIC8vIElmIEFQSSByZXR1cm5lZCBhbiBlbnZlbG9wZSwgZGlnIGluc2lkZQogICAgY29uc3QgdW53cmFwcGVkID0KICAgICAgKGRwICYmIChkcC5kaWdpX3BhY2sgfHwgZHAuZGlnaXBhY2sgfHwgZHAuZGlnaVBhY2sgfHwgZHAuRElHSV9QQUNLKSkgfHwKICAgICAgKGRwICYmIChkcC5vdXRwdXRzIHx8IGRwLm91dHB1dCB8fCBkcC5yZXN1bHQgfHwgZHAuZGF0YSB8fCBkcC5wYXlsb2FkKSkgfHwKICAgICAgbnVsbDsKCiAgICBpZiAodW53cmFwcGVkKSBkcCA9IHVud3JhcHBlZDsKCiAgICAvLyBJZiBzdGlsbCBlY2hvLWxpa2UgKG9ubHkgcmVjZWl2ZWQpLCBzaG93IGEgaGVscGZ1bCBtZXNzYWdlCiAgICBpZiAoZHAgJiYgdHlwZW9mIGRwID09PSAib2JqZWN0IiAmJiBkcC5yZWNlaXZlZCAmJiAhZHAub3V0cHV0cyAmJiAhZHAub3V0cHV0ICYmICFkcC5yZXN1bHQgJiYgIWRwLmRpZ2lfcGFjayAmJiAhZHAuZGlnaXBhY2spIHsKICAgICAgY29uc3QgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICAgIG1zZy5jbGFzc05hbWUgPSAibmctY2FyZCI7CiAgICAgIG1zZy5zdHlsZS5wYWRkaW5nID0gIjEwcHgiOwogICAgICBtc2cuaW5uZXJIVE1MID0KICAgICAgICAiPGI+RUNITyByZXNwb25zZTwvYj46IOCkheCkreClgCBzZXJ2ZXIg4KSo4KWHIOCkuOCkv+CksOCljeCkqyDgpIbgpKrgpJXgpL4gaW5wdXQgKHJlY2VpdmVkKSDgpLLgpYzgpJ/gpL7gpK/gpL4g4KS54KWILCBEaWdpUGFjayBmb3JtYXRzIOCkqOCkueClgOCkguClpDxicj4iICsKICAgICAgICAiUkVBTCBtb2RlIOCkruClh+CkgiBHZW5lcmF0ZSDgpJXgpLDgpYfgpIIg4KSk4KS+4KSV4KS/IHdlYi92aWRlby95b3V0dWJlIOCkhuCkpuCkvyBvdXRwdXRzIOCkhuCkj+CkguClpCI7CiAgICAgIGhvc3QuYXBwZW5kQ2hpbGQobXNnKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgLy8gQWxzbzogaWYgZHAubW9kZSBpcyBlY2hvLCBoaW50CiAgICBpZiAoZHAgJiYgdHlwZW9mIGRwID09PSAib2JqZWN0IiAmJiBTdHJpbmcoZHAubW9kZSB8fCAiIikudG9Mb3dlckNhc2UoKSA9PT0gImVjaG8iKSB7CiAgICAgIGNvbnN0IG1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICBtc2cuY2xhc3NOYW1lID0gIm5nLWNhcmQiOwogICAgICBtc2cuc3R5bGUucGFkZGluZyA9ICIxMHB4IjsKICAgICAgbXNnLmlubmVySFRNTCA9CiAgICAgICAgIjxiPm1vZGU6IGVjaG88L2I+IOCkruCkv+CksuCkviDgpLngpYgg4oCUIOCkh+CkuCByZXNwb25zZSDgpK7gpYfgpIIgZm9ybWF0dGVkIG91dHB1dHMg4KSo4KS54KWA4KSCIOCkueCli+CkguCkl+Clh+ClpCBSRUFMIG1vZGUg4KSu4KWH4KSCIEdlbmVyYXRlIOCkleCksOClh+CkguClpCI7CiAgICAgIGhvc3QuYXBwZW5kQ2hpbGQobXNnKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgfSBjYXRjaCAoZSkge30KCgogIGNvbnN0IGZvcm1hdHMgPSBOR19waWNrRGlnaVBhY2tGb3JtYXRzKGRwKTsKCiAgaWYgKCFmb3JtYXRzLmxlbmd0aCkgewogICAgY29uc3QgZW1wdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKICAgIGVtcHR5LmNsYXNzTmFtZSA9ICJuZy1jYXJkIjsKICAgIGVtcHR5LnN0eWxlLnBhZGRpbmcgPSAiMTBweCI7CiAgICBlbXB0eS50ZXh0Q29udGVudCA9ICJObyBmb3JtYXR0ZWQgRGlnaVBhY2sgZm9ybWF0cyBmb3VuZCAoZW1wdHkpLiI7CiAgICBob3N0LmFwcGVuZENoaWxkKGVtcHR5KTsKICAgIHJldHVybiB0cnVlOwogIH0KCiAgZm9ybWF0cy5mb3JFYWNoKChmLCBpKSA9PiB7CiAgICBjb25zdCBjYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VjdGlvbiIpOwogICAgY2FyZC5jbGFzc05hbWUgPSAibmctY2FyZCI7CiAgICBjYXJkLnN0eWxlLnBhZGRpbmcgPSAiMTBweCI7CiAgICBjYXJkLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICIxMHB4IjsKCiAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICBoZWFkLnN0eWxlLmRpc3BsYXkgPSAiZmxleCI7CiAgICBoZWFkLnN0eWxlLmFsaWduSXRlbXMgPSAiY2VudGVyIjsKICAgIGhlYWQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAic3BhY2UtYmV0d2VlbiI7CiAgICBoZWFkLnN0eWxlLmdhcCA9ICI4cHgiOwoKICAgIGNvbnN0IGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKICAgIGguc3R5bGUuZm9udFdlaWdodCA9ICI3MDAiOwogICAgaC5zdHlsZS5mb250U2l6ZSA9ICIxNHB4IjsKICAgIGgudGV4dENvbnRlbnQgPSBmLnRpdGxlIHx8ICgiRm9ybWF0ICIgKyAoaSsxKSk7CgogICAgY29uc3QgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnV0dG9uIik7CiAgICBidG4udHlwZSA9ICJidXR0b24iOwogICAgYnRuLnRleHRDb250ZW50ID0gIkNvcHkiOwogICAgYnRuLmNsYXNzTmFtZSA9ICJuZy1idG4gbmctYnRuLW1pbmkiOyAvLyBpZiB5b3UgaGF2ZSBtaW5pIGJ1dHRvbiBjbGFzczsgZWxzZSBoYXJtbGVzcwogICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgKCkgPT4gewogICAgICBOR19jb3B5VGV4dFRvQ2xpcGJvYXJkKGYudGV4dCB8fCAiIikudGhlbigoKSA9PiB7CiAgICAgICAgYnRuLnRleHRDb250ZW50ID0gIkNvcGllZCI7CiAgICAgICAgc2V0VGltZW91dCgoKSA9PiAoYnRuLnRleHRDb250ZW50ID0gIkNvcHkiKSwgOTAwKTsKICAgICAgfSk7CiAgICB9KTsKCiAgICBoZWFkLmFwcGVuZENoaWxkKGgpOwogICAgaGVhZC5hcHBlbmRDaGlsZChidG4pOwoKICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJwcmUiKTsKICAgIGJvZHkuc3R5bGUud2hpdGVTcGFjZSA9ICJwcmUtd3JhcCI7CiAgICBib2R5LnN0eWxlLm1hcmdpbiA9ICIxMHB4IDAgMCAwIjsKICAgIGJvZHkuc3R5bGUuZm9udFNpemUgPSAiMTNweCI7CiAgICBib2R5LnN0eWxlLmxpbmVIZWlnaHQgPSAiMS4zNSI7CiAgICBib2R5LnRleHRDb250ZW50ID0gZi50ZXh0IHx8ICIiOwoKICAgIGNhcmQuYXBwZW5kQ2hpbGQoaGVhZCk7CiAgICBjYXJkLmFwcGVuZENoaWxkKGJvZHkpOwoKICAgIGhvc3QuYXBwZW5kQ2hpbGQoY2FyZCk7CiAgfSk7CgogIHJldHVybiB0cnVlOwp9CndpbmRvdy5OR19yZW5kZXJEaWdpUGFja0Zvcm1hdHRlZCA9IE5HX3JlbmRlckRpZ2lQYWNrRm9ybWF0dGVkOwp3aW5kb3cuX19OR19SRU5ERVJfRVhQT1JUX09LX18gPSB0cnVlOwoKCi8qID09PSBOR19TVE9SWVZJRVdfRk9STUFUVEVEX1JFTkRFUl9WMV9FTkQgKDIwMjYwMjA1KSA9PT0gKi8KCgoKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAvLyBmYWxsYmFjazogYXQgbGVhc3QgbWlycm9yIG5nUmVzcG9uc2UgaW50byBzdG9yeXZpZXctb3V0CiAgICAgICAgICAgICAgdmFyIG91dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJuZy1zdG9yeXZpZXctb3V0Iik7CiAgICAgICAgICAgICAgdmFyIHJlc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmdSZXNwb25zZSIpOwogICAgICAgICAgICAgIGlmIChvdXQgJiYgcmVzcCkgewogICAgICAgICAgICAgICAgb3V0LnRleHRDb250ZW50ID0gKHJlc3AudGV4dENvbnRlbnQgfHwgIiIpLnRyaW0oKSB8fCAiKG5vIHJlc3BvbnNlIHlldCkiOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gc2Nyb2xsIGludG8gdmlldwogICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7CiAgICAgICAgICAgICAgdmFyIHAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmctc3Rvcnl2aWV3Iik7CiAgICAgICAgICAgICAgaWYgKHAgJiYgcC5zY3JvbGxJbnRvVmlldykgcC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiJzbW9vdGgiLCBibG9jazoic3RhcnQiIH0pOwogICAgICAgICAgICB9LCA1MCk7CiAgICAgICAgICB9Y2F0Y2goZSl7fQogICAgICAgIH0pOyAgLy8gY2xvc2VzOiByZXR1cm4gci50ZXh0KCkudGhlbihmdW5jdGlvbih0ZXh0KXsgLi4uIH0pCgoKCgoKICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKXsKICAgICAgICBzZXRCYW5uZXIoIltOR10gRVJST1I6ICIgKyAoZXJyICYmIGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKSkpOwogICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7CiAgICAgICAgaW5GbGlnaHQgPSBmYWxzZTsKICAgICAgICBidG4uZGlzYWJsZWQgPSBmYWxzZTsKICAgICAgICBidG4ucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOwogICAgICB9KTsKCiAgICB9LCB0cnVlKTsKCiAgICBzZXRCYW5uZXIoIltOR10gR2VuZXJhdGUgcmVhZHkuIENsaWNrIEdlbmVyYXRlIERJR0lfUEFDSy4iKTsKICB9CgogIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAibG9hZGluZyIpIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIkRPTUNvbnRlbnRMb2FkZWQiLCB3aXJlLCB7IG9uY2U6dHJ1ZSB9KTsKICBlbHNlIHdpcmUoKTsKfSkoKTsKLyogPT09IE5HX1NUT1JZVklFV19GT1JNQVRURURfUkVOREVSX1RPUExFVkVMX1YxX1NUQVJUICgyMDI2MDIwNSkgPT09ICovCihmdW5jdGlvbigpewogIGlmICh3aW5kb3cuTkdfcmVuZGVyRGlnaVBhY2tGb3JtYXR0ZWQpIHJldHVybjsgLy8gYWxyZWFkeSBpbnN0YWxsZWQKCiAgZnVuY3Rpb24gTkdfc2FmZVRpdGxlRnJvbUtleShrKXsKICAgIHRyeXsKICAgICAgcmV0dXJuIFN0cmluZyhrIHx8ICIiKQogICAgICAgIC5yZXBsYWNlKC9bX1wtXSsvZywiICIpCiAgICAgICAgLnJlcGxhY2UoL1xzKy9nLCIgIikKICAgICAgICAudHJpbSgpCiAgICAgICAgLnJlcGxhY2UoL1xiXHcvZywgYyA9PiBjLnRvVXBwZXJDYXNlKCkpOwogICAgfWNhdGNoKGUpeyByZXR1cm4gU3RyaW5nKGt8fCJGb3JtYXQiKTsgfQogIH0KCiAgZnVuY3Rpb24gTkdfY29weVRleHRUb0NsaXBib2FyZCh0ZXh0KXsKICAgIGNvbnN0IHQgPSAodGV4dCA9PSBudWxsKSA/ICIiIDogU3RyaW5nKHRleHQpOwogICAgaWYgKG5hdmlnYXRvci5jbGlwYm9hcmQgJiYgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQpIHsKICAgICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHQpLmNhdGNoKCgpID0+IHsKICAgICAgICBjb25zdCB0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIik7CiAgICAgICAgdGEudmFsdWUgPSB0OwogICAgICAgIHRhLnN0eWxlLnBvc2l0aW9uID0gImZpeGVkIjsKICAgICAgICB0YS5zdHlsZS5sZWZ0ID0gIi05OTk5cHgiOwogICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGEpOwogICAgICAgIHRhLmZvY3VzKCk7IHRhLnNlbGVjdCgpOwogICAgICAgIHRyeSB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKCJjb3B5Iik7IH0gY2F0Y2goZSl7fQogICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGEpOwogICAgICB9KTsKICAgIH0KICAgIGNvbnN0IHRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTsKICAgIHRhLnZhbHVlID0gdDsKICAgIHRhLnN0eWxlLnBvc2l0aW9uID0gImZpeGVkIjsKICAgIHRhLnN0eWxlLmxlZnQgPSAiLTk5OTlweCI7CiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRhKTsKICAgIHRhLmZvY3VzKCk7IHRhLnNlbGVjdCgpOwogICAgdHJ5IHsgZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNvcHkiKTsgfSBjYXRjaChlKXt9CiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhKTsKICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsKICB9CgogIGZ1bmN0aW9uIE5HX3BpY2tEaWdpUGFja0Zvcm1hdHMoZHApewogICAgY29uc3Qgb3V0ID0gW107CiAgICBpZiAoIWRwKSByZXR1cm4gb3V0OwoKICAgIGlmIChBcnJheS5pc0FycmF5KGRwLmZvcm1hdHMpKSB7CiAgICAgIGRwLmZvcm1hdHMuZm9yRWFjaCgoaXQsIGlkeCkgPT4gewogICAgICAgIGNvbnN0IGtleSA9IGl0ICYmIChpdC5rZXkgfHwgaXQubmFtZSB8fCBpdC50aXRsZSB8fCAoImZvcm1hdF8iK2lkeCkpOwogICAgICAgIGNvbnN0IHRpdGxlID0gaXQgJiYgKGl0LnRpdGxlIHx8IGl0Lm5hbWUgfHwgTkdfc2FmZVRpdGxlRnJvbUtleShrZXkpKTsKICAgICAgICBjb25zdCB0ZXh0ID0gaXQgJiYgKGl0LnRleHQgfHwgaXQuY29udGVudCB8fCBpdC5ib2R5IHx8ICIiKTsKICAgICAgICBpZiAoU3RyaW5nKHRleHR8fCIiKS50cmltKCkpIG91dC5wdXNoKHsga2V5LCB0aXRsZSwgdGV4dDogU3RyaW5nKHRleHQpIH0pOwogICAgICB9KTsKICAgICAgaWYgKG91dC5sZW5ndGgpIHJldHVybiBvdXQ7CiAgICB9CgogICAgaWYgKHR5cGVvZiBkcCA9PT0gIm9iamVjdCIpIHsKICAgICAgY29uc3Qgc2tpcCA9IG5ldyBTZXQoWyJvayIsInRzIiwibWV0YSIsInJlZnMiLCJzb3VyY2VzIiwic291cmNlIiwibW9kZWwiLCJtb2RlIiwic3RhdHVzIiwiZXJyb3IiLCJyYXciLCJqc29uIiwiZGVidWciLCJ0ZWxlbWV0cnkiLCJfbWV0YSIsIl9kZWJ1ZyJdKTsKICAgICAgY29uc3QgcHJlZmVycmVkID0gWyJ3ZWJfYXJ0aWNsZSIsImFydGljbGUiLCJuZXdzX2FydGljbGUiLCJ2aWRlb19zY3JpcHQiLCJ2aWRlbyIsInR2X3NjcmlwdCIsInlvdXR1YmUiLCJ5b3V0dWJlX3NjcmlwdCIsInl0X3NjcmlwdCIsInNob3J0cyIsInJlZWwiLCJyZWVscyIsImluc3RhX3JlZWwiLCJzb2NpYWwiLCJzb2NpYWxfcG9zdHMiLCJ4X3RocmVhZCIsInR3aXR0ZXJfdGhyZWFkIiwiaGVhZGxpbmUiLCJzdW1tYXJ5IiwiYnVsbGV0X3BvaW50cyIsImFuY2hvcnMiLCJwcm9tcHRzIl07CiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkcCk7CiAgICAgIGNvbnN0IG9yZGVyZWQgPSBbXTsKICAgICAgcHJlZmVycmVkLmZvckVhY2goayA9PiB7IGlmIChrZXlzLmluY2x1ZGVzKGspKSBvcmRlcmVkLnB1c2goayk7IH0pOwogICAgICBrZXlzLmZvckVhY2goayA9PiB7IGlmICghb3JkZXJlZC5pbmNsdWRlcyhrKSkgb3JkZXJlZC5wdXNoKGspOyB9KTsKCiAgICAgIG9yZGVyZWQuZm9yRWFjaCgoaykgPT4gewogICAgICAgIGlmIChza2lwLmhhcyhrKSkgcmV0dXJuOwogICAgICAgIGNvbnN0IHYgPSBkcFtrXTsKICAgICAgICBpZiAodiA9PSBudWxsKSByZXR1cm47CgogICAgICAgIGlmICh0eXBlb2YgdiA9PT0gIm9iamVjdCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHsKICAgICAgICAgIGNvbnN0IG1heWJlID0gdi50ZXh0IHx8IHYuY29udGVudCB8fCB2LmJvZHkgfHwgdi5zY3JpcHQgfHwgdi5vdXRwdXQgfHwgIiI7CiAgICAgICAgICBpZiAoU3RyaW5nKG1heWJlfHwiIikudHJpbSgpKSBvdXQucHVzaCh7IGtleTogaywgdGl0bGU6IE5HX3NhZmVUaXRsZUZyb21LZXkoayksIHRleHQ6IFN0cmluZyhtYXliZSkgfSk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICBjb25zdCB0ZXh0ID0gQXJyYXkuaXNBcnJheSh2KSA/IHYuam9pbigiXG4iKSA6IFN0cmluZyh2KTsKICAgICAgICBpZiAodGV4dC50cmltKCkpIG91dC5wdXNoKHsga2V5OiBrLCB0aXRsZTogTkdfc2FmZVRpdGxlRnJvbUtleShrKSwgdGV4dCB9KTsKICAgICAgfSk7CiAgICB9CgogICAgcmV0dXJuIG91dDsKICB9CgogIGZ1bmN0aW9uIE5HX3JlbmRlckRpZ2lQYWNrRm9ybWF0dGVkKGRwKXsKICAgIGNvbnN0IGhvc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgibmctc3Rvcnl2aWV3LWZvcm1hdHRlZCIpOwogICAgaWYgKCFob3N0KSByZXR1cm4gZmFsc2U7CiAgICBob3N0LmlubmVySFRNTCA9ICIiOwoKICAgIC8vIHVud3JhcCB3cmFwcGVycwogICAgdHJ5IHsKICAgICAgY29uc3QgdW53cmFwcGVkID0KICAgICAgICAoZHAgJiYgKGRwLmRpZ2lfcGFjayB8fCBkcC5kaWdpcGFjayB8fCBkcC5kaWdpUGFjayB8fCBkcC5ESUdJX1BBQ0spKSB8fAogICAgICAgIChkcCAmJiAoZHAub3V0cHV0cyB8fCBkcC5vdXRwdXQgfHwgZHAucmVzdWx0IHx8IGRwLmRhdGEgfHwgZHAucGF5bG9hZCkpIHx8CiAgICAgICAgbnVsbDsKICAgICAgaWYgKHVud3JhcHBlZCkgZHAgPSB1bndyYXBwZWQ7CgogICAgICBpZiAoZHAgJiYgdHlwZW9mIGRwID09PSAib2JqZWN0IiAmJiBTdHJpbmcoZHAubW9kZSB8fCAiIikudG9Mb3dlckNhc2UoKSA9PT0gImVjaG8iKSB7CiAgICAgICAgY29uc3QgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICAgICAgbXNnLmNsYXNzTmFtZSA9ICJuZy1jYXJkIjsKICAgICAgICBtc2cuc3R5bGUucGFkZGluZyA9ICIxMHB4IjsKICAgICAgICBtc2cuaW5uZXJIVE1MID0gIjxiPm1vZGU6IGVjaG88L2I+IOCkruCkv+CksuCkviDgpLngpYgg4oCUIOCkh+CkuCByZXNwb25zZSDgpK7gpYfgpIIgZm9ybWF0dGVkIG91dHB1dHMg4KSo4KS54KWA4KSCIOCkueCli+CkguCkl+Clh+ClpCBSRUFMIG1vZGUg4KSu4KWH4KSCIEdlbmVyYXRlIOCkleCksOClh+CkguClpCI7CiAgICAgICAgaG9zdC5hcHBlbmRDaGlsZChtc2cpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGlmIChkcCAmJiB0eXBlb2YgZHAgPT09ICJvYmplY3QiICYmIGRwLnJlY2VpdmVkICYmICFkcC5vdXRwdXRzICYmICFkcC5vdXRwdXQgJiYgIWRwLnJlc3VsdCAmJiAhZHAuZGlnaV9wYWNrICYmICFkcC5kaWdpcGFjaykgewogICAgICAgIGNvbnN0IG1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICAgIG1zZy5jbGFzc05hbWUgPSAibmctY2FyZCI7CiAgICAgICAgbXNnLnN0eWxlLnBhZGRpbmcgPSAiMTBweCI7CiAgICAgICAgbXNnLmlubmVySFRNTCA9ICI8Yj5FQ0hPIHJlc3BvbnNlPC9iPjog4KSF4KSt4KWAIHNlcnZlciDgpKjgpYcg4KS44KS/4KSw4KWN4KSrIOCkhuCkquCkleCkviBpbnB1dCAocmVjZWl2ZWQpIOCksuCljOCkn+CkvuCkr+CkviDgpLngpYgsIERpZ2lQYWNrIGZvcm1hdHMg4KSo4KS54KWA4KSC4KWkPGJyPlJFQUwgbW9kZSDgpK7gpYfgpIIgR2VuZXJhdGUg4KSV4KSw4KWH4KSCIOCkpOCkvuCkleCkvyB3ZWIvdmlkZW8veW91dHViZSDgpIbgpKbgpL8gb3V0cHV0cyDgpIbgpI/gpILgpaQiOwogICAgICAgIGhvc3QuYXBwZW5kQ2hpbGQobXNnKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfSBjYXRjaChlKSB7fQoKICAgIGNvbnN0IGZvcm1hdHMgPSBOR19waWNrRGlnaVBhY2tGb3JtYXRzKGRwKTsKCiAgICBpZiAoIWZvcm1hdHMubGVuZ3RoKSB7CiAgICAgIGNvbnN0IGVtcHR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICAgIGVtcHR5LmNsYXNzTmFtZSA9ICJuZy1jYXJkIjsKICAgICAgZW1wdHkuc3R5bGUucGFkZGluZyA9ICIxMHB4IjsKICAgICAgZW1wdHkudGV4dENvbnRlbnQgPSAiTm8gZm9ybWF0dGVkIERpZ2lQYWNrIGZvcm1hdHMgZm91bmQgKGVtcHR5KS4iOwogICAgICBob3N0LmFwcGVuZENoaWxkKGVtcHR5KTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZm9ybWF0cy5mb3JFYWNoKChmLCBpKSA9PiB7CiAgICAgIGNvbnN0IGNhcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWN0aW9uIik7CiAgICAgIGNhcmQuY2xhc3NOYW1lID0gIm5nLWNhcmQiOwogICAgICBjYXJkLnN0eWxlLnBhZGRpbmcgPSAiMTBweCI7CiAgICAgIGNhcmQuc3R5bGUubWFyZ2luQm90dG9tID0gIjEwcHgiOwoKICAgICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICBoZWFkLnN0eWxlLmRpc3BsYXkgPSAiZmxleCI7CiAgICAgIGhlYWQuc3R5bGUuYWxpZ25JdGVtcyA9ICJjZW50ZXIiOwogICAgICBoZWFkLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gInNwYWNlLWJldHdlZW4iOwogICAgICBoZWFkLnN0eWxlLmdhcCA9ICI4cHgiOwoKICAgICAgY29uc3QgaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICBoLnN0eWxlLmZvbnRXZWlnaHQgPSAiNzAwIjsKICAgICAgaC5zdHlsZS5mb250U2l6ZSA9ICIxNHB4IjsKICAgICAgaC50ZXh0Q29udGVudCA9IGYudGl0bGUgfHwgKCJGb3JtYXQgIiArIChpKzEpKTsKCiAgICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJ1dHRvbiIpOwogICAgICBidG4udHlwZSA9ICJidXR0b24iOwogICAgICBidG4udGV4dENvbnRlbnQgPSAiQ29weSI7CiAgICAgIGJ0bi5jbGFzc05hbWUgPSAibmctYnRuIG5nLWJ0bi1taW5pIjsKICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgKCkgPT4gewogICAgICAgIE5HX2NvcHlUZXh0VG9DbGlwYm9hcmQoZi50ZXh0IHx8ICIiKS50aGVuKCgpID0+IHsKICAgICAgICAgIGJ0bi50ZXh0Q29udGVudCA9ICJDb3BpZWQiOwogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiAoYnRuLnRleHRDb250ZW50ID0gIkNvcHkiKSwgOTAwKTsKICAgICAgICB9KTsKICAgICAgfSk7CgogICAgICBoZWFkLmFwcGVuZENoaWxkKGgpOwogICAgICBoZWFkLmFwcGVuZENoaWxkKGJ0bik7CgogICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicHJlIik7CiAgICAgIGJvZHkuc3R5bGUud2hpdGVTcGFjZSA9ICJwcmUtd3JhcCI7CiAgICAgIGJvZHkuc3R5bGUubWFyZ2luID0gIjEwcHggMCAwIDAiOwogICAgICBib2R5LnN0eWxlLmZvbnRTaXplID0gIjEzcHgiOwogICAgICBib2R5LnN0eWxlLmxpbmVIZWlnaHQgPSAiMS4zNSI7CiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSBmLnRleHQgfHwgIiI7CgogICAgICBjYXJkLmFwcGVuZENoaWxkKGhlYWQpOwogICAgICBjYXJkLmFwcGVuZENoaWxkKGJvZHkpOwogICAgICBob3N0LmFwcGVuZENoaWxkKGNhcmQpOwogICAgfSk7CgogICAgcmV0dXJuIHRydWU7CiAgfQoKICB3aW5kb3cuTkdfcmVuZGVyRGlnaVBhY2tGb3JtYXR0ZWQgPSBOR19yZW5kZXJEaWdpUGFja0Zvcm1hdHRlZDsKICB3aW5kb3cuX19OR19SRU5ERVJfRVhQT1JUX09LX18gPSB0cnVlOwp9KSgpOwogLyogPT09IE5HX1NUT1JZVklFV19GT1JNQVRURURfUkVOREVSX1RPUExFVkVMX1YxX0VORCAoMjAyNjAyMDUpID09PSAqLwoKCgoKCgoKCgoKCgoKCg==";
// Hard route: serve Generate JS even if Assets manifest misses it
if (path === "/js/ng_generate_v1.js" || path === "/ng_generate_v1.js") {
  try {
    const body = (typeof atob === "function") ? atob(__NG_GEN_JS_B64__) : "";
    return new Response(body, { status: 200, headers: { "content-type": "application/javascript; charset=utf-8" } });
  } catch (e) {
    return new Response("// NG_GENERATE inline serve failed", { status: 500, headers: { "content-type": "application/javascript; charset=utf-8" } });
  }
}

/* === NG_STUB_MISSING_UI_JS_V1_START (20260201) === */
if (
  path === "/ng_toolbar_actions_v1.js" ||
  path === "/js/ng_toolbar_actions_v1.js" ||
  path === "/ng_prompt_builder_v1.js" ||
  path === "/js/ng_prompt_builder_v1.js"
) {
  const body =
    path.includes("toolbar_actions")
      ? "// TEMP STUB: ng_toolbar_actions_v1.js (missing)\nwindow.__NG_TOOLBAR_ACTIONS_STUB__=true;\n"
      : "// TEMP STUB: ng_prompt_builder_v1.js (missing)\nwindow.__NG_PROMPT_BUILDER_STUB__=true;\n";

  return new Response(body, {
    status: 200,
    headers: { "content-type": "application/javascript; charset=utf-8" },
  });
}
/* === NG_STUB_MISSING_UI_JS_V1_END === */


    // --- /api/bytes/latest via Durable Object (persistent) ---
    if (url.pathname === "/api/bytes/latest") {
      const id = env.BYTES_DO.idFromName("latest");
      const stub = env.BYTES_DO.get(id);
      return stub.fetch(request);
    }
    // --- end /api/bytes/latest ---

    // CORS preflight
    if (request.method === "OPTIONS") {
      return new globalThis.Response(null, { status: 204, headers: corsHeaders(request) });
    }
    // --- NG_ASSETS_FALLBACK_V1_START (20260201) ---
    // If this is not an API route, try serving static assets from /public
    // This prevents "Promise did not resolve to Response" on missing return paths.
    try {
      const p = new URL(request.url).pathname || "/";
      const isApi = p === "/health" || p.startsWith("/api/");
      if (!isApi && env && env.ASSETS && typeof env.ASSETS.fetch === "function") {
        return env.ASSETS.fetch(request);
      }
    } catch (e) { /* ignore */ }
    // --- NG_ASSETS_FALLBACK_V1_END ---



    const has_openai_key = !!(env && env.OPENAI_API_KEY);

    // Ping
    if (path === "/ping") {
      return json(
        { ok: true, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key },
        200,
        corsHeaders(request)
      );
    }


// NG_PATCH_START:TRANSCRIPT_LATEST_V1
// Transcript latest (GET/POST; in-memory store; always returns Response)
if ((path === "/api/transcript/latest" || path === "/transcript/latest") && request.method === "POST") {
  const body = await readJson(request);const text = (body && body.text != null) ? String(body.text) : "";
  const latest = {
    text,
    source: (body && body.source != null) ? String(body.source) : null,
    ts: (body && body.ts) ? String(body.ts) : new Date().toISOString(),
  };

  globalThis.__NG_LATEST_TRANSCRIPT__ = latest;

  const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
  const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
  return new Response(JSON.stringify({ ok: true, latest, text: latest.text, ts: new Date().toISOString() }), { status: 200, headers });
}

if ((path === "/transcript/latest" || path === "/api/transcript/latest") && request.method === "GET") {
  const latest = globalThis.__NG_LATEST_TRANSCRIPT__ || null;
  const text = (latest && latest.text) ? String(latest.text) : "";
  const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
  const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
  return new Response(JSON.stringify({ ok: true, latest, text, ts: new Date().toISOString() }), { status: 200, headers });
}
// NG_PATCH_END:TRANSCRIPT_LATEST_V1
    
    // Digi-pack API
    if (path === "/api/digi-pack" && request.method === "POST") {      
  const body = await readJson(request);
  const promptObj = safeParsePrompt(body);

  // --- NG_MODE_RESOLVE_V1 (20260205) ---
  // prefer request body mode; fallback to env; finally echo
  const reqModeRaw =
    (body && (body.mode || body.run_mode || body.MODE)) ||
    (promptObj && (promptObj.mode || promptObj.run_mode || promptObj.MODE)) ||
    (env?.GEN_MODE) ||
    "echo";
  const mode = String(reqModeRaw).toLowerCase().trim();
  // --- /NG_MODE_RESOLVE_V1 ---

      const model = String(env?.OPENAI_MODEL || "gpt-4o");
      const max_output_tokens = Number(env?.MAX_OUTPUT_TOKENS || 2200);

      // Echo mode (old behavior)
      if (mode !== "openai") {
        return json(
          {
            ok: true,
            ts: new Date().toISOString(),
            path,
            mode,
            model,
            max_output_tokens,
            entry_marker: ENTRY_MARKER,
            has_openai_key,
            received: promptObj,
          },
          200,
          corsHeaders(request)
        );
      }

      // OpenAI mode requested but key missing
      if (!has_openai_key) {
        return json(
          { ok: false, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key, error: "OPENAI_API_KEY missing" },
          400,
          corsHeaders(request)
        );
      }

      /* === NG_OPENAI_DIGIPACK_V1_START (20260202) === */
      // OpenAI mode: call OpenAI Chat Completions (server-side)
      try {
        const story = String(promptObj?.story || "").trim();
        const lang = String(promptObj?.lang || "hi").trim();
        const format = String(promptObj?.format || "DIGI_PACK").trim();

        if (!story) {
          return json(
            { ok: false, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key, error: "Missing story", },
            400,
            corsHeaders(request)
          );
        }

        const sys = [
          "You are NewsGenie Digital Producer.",
          "Generate a newsroom-ready digital pack from the given story.",
          "Return STRICT JSON only (no markdown).",
          "Language: " + lang + ".",
          "Pack type: " + format + ".",
          "Keep it factual; do not invent names, dates, places not in the input."
        ].join(" ");

        const userMsg = [
          "STORY:",
          story,
          "",
          "OUTPUT_JSON_SCHEMA:",
          "{",
         '  "headline": "string",',
'  "summary": "string",',
'  "key_points": ["string"],',
'  "web_article": {"title":"string","dek":"string","body":"string"},',
'  "video_script": {"anchor_intro":"string","vo":"string","outro":"string"},',
'  "youtube": {"title":"string","description":"string","tags":["string"]},',
'  "reel": {"hook":"string","script":"string","cta":"string"},',
'  "social": {"x":"string","instagram_caption":"string","whatsapp":"string","hashtags":["string"]},',
'  "seo": {"meta_title":"string","meta_description":"string","slug":"string","keywords":["string"]},',
'  "refs": ["string"]',

          "}"
        ].join("\n");

        const payload = {
          model,
          temperature: 0.2,
          max_tokens: max_output_tokens,
          messages: [
            { role: "system", content: sys },
            { role: "user", content: userMsg }
          ]
        };

        const r = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "authorization": `Bearer ${env.OPENAI_API_KEY}`
          },
          body: JSON.stringify(payload)
        });

        const j = await r.json().catch(() => ({}));

        if (!r.ok) {
          return json(
            {
              ok: false,
              ts: new Date().toISOString(),
              path,
              entry_marker: ENTRY_MARKER,
              has_openai_key,
              error: "OpenAI request failed",
              status: r.status,
              details: j
            },
            502,
            corsHeaders(request)
          );
        }

        const content = String(j?.choices?.[0]?.message?.content || "").trim();

                // ---- parse JSON + build copy-ready text ----
        let output_json = null;
        let parse_ok = false;
        let parse_error = null;

        try {
          output_json = JSON.parse(content);
          parse_ok = true;
        } catch (e) {
          parse_ok = false;
          parse_error = String(e?.message || e);
        }

        const safeStr = (v) => (typeof v === "string" ? v.trim() : "");
        const safeArr = (v) => (Array.isArray(v) ? v.map(x => safeStr(x)).filter(Boolean) : []);

        let copy_text = "";
        if (parse_ok && output_json) {
          const h = safeStr(output_json.headline);
          const s = safeStr(output_json.summary);
          const kp = safeArr(output_json.key_points);

          const wa = output_json.web_article || {};
          const vs = output_json.video_script || {};
          const yt = output_json.youtube || {};
          const rl = output_json.reel || {};
         const so = output_json.social || {};
const seo = output_json.seo || {};
const refs = output_json.refs || [];

// x can be string OR array
const xPosts = Array.isArray(so.x) ? so.x : (typeof so.x === "string" && so.x.trim() ? [so.x.trim()] : []);

// hashtags can be string OR array
const hashtags = Array.isArray(so.hashtags) ? so.hashtags
  : (typeof so.hashtags === "string" && so.hashtags.trim() ? [so.hashtags.trim()] : []);

          copy_text = [
            "=== HEADLINE ===",
            h || "(missing)",
            "",
            "=== SUMMARY ===",
            s || "(missing)",
            "",
            "=== KEY POINTS ===",
            kp.length ? kp.map((p, i) => `${i + 1}. ${p}`).join("\n") : "(missing)",
            "",
            "=== WEB ARTICLE ===",
            "Title: " + (safeStr(wa.title) || "(missing)"),
            "",
            (safeStr(wa.body) || "(missing)"),
            "",
            "SEO Keywords: " + (safeArr(wa.seo_keywords).join(", ") || "(missing)"),
            "",
            "=== VIDEO SCRIPT ===",
            "Anchor Intro:",
            safeStr(vs.anchor_intro) || "(missing)",
            "",
            "VO:",
            safeStr(vs.vo) || "(missing)",
            "",
            "Outro:",
            safeStr(vs.outro) || "(missing)",
            "",
            "=== YOUTUBE ===",
            "Title: " + (safeStr(yt.title) || "(missing)"),
            "Description:",
            safeStr(yt.description) || "(missing)",
            "",
            "Tags: " + (safeArr(yt.tags).join(", ") || "(missing)"),
            "",
            "=== REEL ===",
            "Hook: " + (safeStr(rl.hook) || "(missing)"),
            "Script:",
            safeStr(rl.script) || "(missing)",
            "",
            "CTA: " + (safeStr(rl.cta) || "(missing)"),
            "",
            "=== SOCIAL ===",
            "X:",
            xPosts.length ? xPosts.map((p, i) => `- ${p}`).join("\n") : "(missing)",
            "",
            "Instagram Caption:",
            safeStr(so.instagram_caption) || "(missing)",
            "",
            "WhatsApp:",
"",
"Hashtags:",
hashtags.length ? hashtags.map(h => `- ${safeStr(h)}`).join("\n") : "(missing)",
"",
"=== SEO ===",
"Meta Title: " + (safeStr(seo.meta_title) || "(missing)"),
"Meta Description: " + (safeStr(seo.meta_description) || "(missing)"),
"Slug: " + (safeStr(seo.slug) || "(missing)"),
"Keywords:",
safeArr(seo.keywords).length ? safeArr(seo.keywords).map(k => `- ${safeStr(k)}`).join("\n") : "(missing)",
"",
"=== REFS ===",
safeArr(refs).length ? safeArr(refs).map(r => `- ${safeStr(r)}`).join("\n") : "(missing)",
"",

            safeStr(so.whatsapp) || "(missing)"
          ].join("\n");
        }

        return json(
          {
            ok: true,
            ts: new Date().toISOString(),
            path,
            mode: "openai",
            model,
            max_output_tokens,
            entry_marker: ENTRY_MARKER,
            has_openai_key,
            output_text: content,        // raw model text (should be JSON string)
            parse_ok,
            parse_error,
            output_json,                 // parsed object (if parse_ok)
            copy_text,                   // copy-ready text (if parse_ok)
            usage: j?.usage || null
          },
          200,
          corsHeaders(request)
        );

      } catch (e) {
        return json(
          {
            ok: false,
            ts: new Date().toISOString(),
            path,
            entry_marker: ENTRY_MARKER,
            has_openai_key,
            error: "OpenAI runtime error",
            message: String(e?.message || e)
          },
          500,
          corsHeaders(request)
        );
      }
/* === NG_OPENAI_DIGIPACK_V1_END (20260202) === */

    }

    // Final fallback (guarantee Response for every request)
    return json(
      { ok: false, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key, error: "Not found" },
      404,
      corsHeaders(request)
    );
  }
};









