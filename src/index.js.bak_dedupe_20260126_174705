const __raw = await request.text();
if (!__raw || !__raw.trim()) {
  // READ-ONLY: empty POST must NOT overwrite stored bytes
  const latest = (globalThis.__NG_BYTES_LATEST || { bytes: null, source: null, ts: null });
  return new Response(JSON.stringify({ ok:true, latest, bytes: latest.bytes ?? null, ts: new Date().toISOString() }), {
    status: 200,
    headers: { "content-type": "application/json; charset=utf-8", "access-control-allow-origin": "*" }
  });
}
let body = {};
try { body = JSON.parse(__raw); } catch(e) {  = {}; }
console.log("[NG_BOOT_SIG] src/index.js 20260119_162645");
}
  }
const __raw = await request.text();
if (!__raw || !__raw.trim()) {
  // READ-ONLY: do not overwrite stored bytes on empty POST
  const latest = (globalThis.__NG_BYTES_LATEST || { bytes: null, source: null, ts: null });
  return new Response(JSON.stringify({ ok:true, latest, bytes: latest.bytes ?? null, ts: new Date().toISOString() }), {
    status: 200,
    headers: { "content-type":"application/json; charset=utf-8", "access-control-allow-origin":"*" }
  });
}
let body = {};
try { body = JSON.parse(__raw); } catch(e) {  = {}; }
console.log("[NG_BOOT_SIG] src/index.js 20260119_162645");
// src/index.js  (BOOT v3: echo + openai mode)
// Root if (path === "/" && request.method === "GET") {   return new globalThis.Response("OK", { status: 200, headers: corsHeaders(request) }); } 
// Uses OpenAI Responses API + Structured Outputs (json_schema)

const ENTRY_MARKER = "BOOTv3-src-indexjs-openai";

function json(data, status = 200, extraHeaders = {}) {
  return new globalThis.Response(JSON.stringify(data, null, 2), {
    status,
    headers: {
      "content-type": "application/json; charset=utf-8",
      ...extraHeaders,
    },
  });
}

function corsHeaders(req) {
  const origin = req.headers.get("Origin") || "*";
  return {
    "Access-Control-Allow-Origin": origin,
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Max-Age": "86400",
  };
}

async function readJson(req) {
  const txt = await req.text();
  if (!txt) return {};
  const clean = txt.replace(/^\uFEFF/, ""); // ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ strip UTF-8 BOM
  try { return JSON.parse(clean); } catch { return { _raw: txt }; }
}


function safeParsePrompt(body) {
  // Accept:
  // 1) { prompt: "{...json...}" }
  // 2) { prompt: {...} }
  // 3) {...} (already the prompt object)
  let p = body?.prompt ?? body ?? {};
  if (typeof p === "string") {
    try { return JSON.parse(p); } catch { return { text: p }; }
  }
  return (p && typeof p === "object") ? p : { text: String(p ?? "") };
}

function extractOutputText(respJson) {
  // Response object example shows:
  // output[0].content[0].type === "output_text" and has "text"
  const out = respJson?.output || [];
  for (const item of out) {
    if (item?.type === "message" && item?.role === "assistant") {
      const content = item?.content || [];
      for (const c of content) {
        if (c?.type === "output_text" && typeof c?.text === "string") return c.text;
      }
    }
  }
  return null;
}

async function withTimeout(promise, ms, label = "timeout") {
  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(label), ms);
  try {
    return await promise(ac.signal);
  } finally {
    clearTimeout(t);
  }
}

export default {
  async fetch(request, env, ctx) {
    /* NG_HEALTH_ROUTE_V1 20260119_162140 */
    try {
      const __u = new URL(request.url);
      if (__u.pathname === "/health" || __u.pathname === "/api/health" || __u.pathname === "/api/health/") {
        return new Response(
          JSON.stringify({ ok: true, ts: new Date().toISOString(), entry: "src/index.js" }),
          { status: 200, headers: { "content-type": "application/json; charset=utf-8" } }
        );
      }
      if (__u.pathname === "/") {
        return new Response("OK", { status: 200, headers: { "content-type": "text/plain; charset=utf-8" } });
      }
    } catch (e) { /* ignore */ }

    const url = new URL(request.url);
    const path = url.pathname;

    // CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(request) });
    }

    const has_openai_key = !!(env && env.OPENAI_API_KEY);

    // Ping
    if (path === "/ping") {
      return json(
        { ok: true, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key },
        200,
        corsHeaders(request)
      );
    }

    // NG_PATCH_START:TRANSCRIPT_LATEST_V1
    // Transcript latest (GET/POST; in-memory store; always returns Response)
    if ((path === "/api/transcript/latest" || path === "/transcript/latest") && request.method === "POST") {
      const body = await readJson(request);
      const text = (body && body.text != null) ? String(body.text) : "";
      const latest = {
        text,
        source: (body && body.source != null) ? String(body.source) : null,
        ts: (body && body.ts) ? String(body.ts) : new Date().toISOString(),
      };
      globalThis.__NG_LATEST_TRANSCRIPT__ = latest;

      const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
      const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
      return new Response(JSON.stringify({ ok: true, latest, text: latest.text, ts: new Date().toISOString() }), { status: 200, headers });
    }

    if ((path === "/transcript/latest" || path === "/api/transcript/latest") && request.method === "GET") {
      const latest = globalThis.__NG_LATEST_TRANSCRIPT__ || null;
      const text = (latest && latest.text) ? String(latest.text) : "";
      const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
      const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
      return new Response(JSON.stringify({ ok: true, latest, text, ts: new Date().toISOString() }), { status: 200, headers });
    }
    // NG_PATCH_END:TRANSCRIPT_LATEST_V1

    // NG_PATCH_START:BYTES_LATEST_V1
    // Bytes latest (GET/POST; in-memory store; always returns Response)
    if ((path === "/api/bytes/latest" || path === "/bytes/latest") && request.method === "POST") {
      const body = await readJson(request);
      const bytes = (body && body.bytes != null) ? body.bytes : (body && body.latest != null ? body.latest : null);

      const latest = {
        bytes,
        source: (body && body.source != null) ? String(body.source) : null,
        ts: (body && body.ts) ? String(body.ts) : new Date().toISOString(),
      };

      globalThis.__NG_LATEST_BYTES__ = latest;

      const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
      const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
      return new Response(JSON.stringify({ ok: true, latest, bytes: latest.bytes, ts: new Date().toISOString() }), { status: 200, headers });
    }

    if ((path === "/api/bytes/latest" || path === "/bytes/latest") && request.method === "GET") {
      const latest = globalThis.__NG_LATEST_BYTES__ || null;
      const bytes = (latest && latest.bytes != null) ? latest.bytes : null;

      const cors = (typeof corsHeaders === "function") ? corsHeaders(request) : {};
      const headers = Object.assign({ "content-type": "application/json; charset=utf-8" }, cors);
      return new Response(JSON.stringify({ ok: true, latest, bytes, ts: new Date().toISOString() }), { status: 200, headers });
    }
    // NG_PATCH_END:BYTES_LATEST_V1

    // Digi-pack API (kept as-is)
    if (path === "/api/digi-pack" && request.method === "POST") {
      const body = await readJson(request);
      const promptObj = safeParsePrompt(body);

      const mode = String(env?.GEN_MODE || "echo").toLowerCase();
      const model = String(env?.OPENAI_MODEL || "gpt-4o");

      const max_output_tokens = Number(env?.MAX_OUTPUT_TOKENS || 2200);

      // Echo mode (old behavior)
      if (mode !== "openai") {
        return json(
          {
            ok: true,
            ts: new Date().toISOString(),
            path,
            mode,
            model,
            entry_marker: ENTRY_MARKER,
            has_openai_key,
            received: promptObj,
          },
          200,
          corsHeaders(request)
        );
      }

      if (!has_openai_key) {
        return json({ ok: false, path, entry_marker: ENTRY_MARKER, has_openai_key, error: "OPENAI_API_KEY missing" }, 400, corsHeaders(request));
      }

      // If your OpenAI mode logic continues below in your file, it will still run.
      // If not present, we'll fall through to 404.
    }

    // final fallback (guarantee Response)
    return json(
      { ok: false, ts: new Date().toISOString(), path, entry_marker: ENTRY_MARKER, has_openai_key, error: "Not found" },
      404,
      corsHeaders(request)
    );
  }
}
