<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NewsGenie Digital Producer</title>
<link rel="icon" href="data:,">

  <style>
    body { font-family: system-ui, Arial; margin: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    label { font-size: 12px; opacity: .8; display:block; margin-bottom:4px; }
    input, select, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; box-sizing: border-box; }
    button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #111; color: #fff; }
    button.secondary { background: #eee; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .panel { margin-top: 12px; padding: 12px; border: 1px solid #ddd; border-radius: 12px; }
    pre { white-space: pre-wrap; word-wrap: break-word; margin: 0; }
    .status { font-size: 13px; }
    .muted { font-size:12px; opacity:.75; margin-top:6px; }
  </style>
</head>

<body>
  <h2>NewsGenie Digital Producer</h2>

  <form id="digi-pack-form" onsubmit="return false;">
    <div class="row">
      <div>
        <label>Topic</label>
        <input name="topic" id="topic" placeholder="E.g., संसद प्रदूषण विवाद" required />
      </div>

      <div>
        <label>Platform</label>
        <select name="platform" id="platform">
          <option value="Digital">Digital</option>
          <option value="Both">Both</option>
          <option value="TV">TV</option>
        </select>
      </div>

      <div>
        <label>Angle (optional)</label>
        <input name="angle" id="angle" placeholder="E.g., विपक्ष बनाम सरकार" />
      </div>
    </div>
<!-- ========================= -->
<!-- Transcript JSON Loader -->
<!-- ========================= -->
<section style="margin-top:12px; padding:12px; border:1px solid #ddd; border-radius:12px;">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <h3 style="margin:0; font-size:14px;">Load Transcript JSON (Reverie)</h3>
    <button type="button" id="btn-load-transcript-json" class="primary">Load</button>
  </div>

  <p style="margin:8px 0 10px; font-size:12px; opacity:.8;">
    Paste Reverie output JSON here (display_text या text). Load करने पर localStorage में save भी होगा.
  </p>

  <textarea id="ta-transcript-json" rows="8"
    style="width:100%; padding:10px; border:1px solid #ccc; border-radius:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;"
    placeholder='Paste JSON here...'></textarea>

  <div style="display:flex; gap:8px; margin-top:10px;">
    <button type="button" id="btn-clear-transcript-json">Clear Saved</button>
    <span id="transcript-load-hint" style="font-size:12px; opacity:.75;"></span>
  </div>
</section>

    <div style="margin-top:10px;">
      <label>Story Type</label>
      <select name="storyType" id="storyType" required>
        <option value="">Select</option>
        <option value="breaking">Breaking</option>
        <option value="developing">Developing</option>
        <option value="explainer">Explainer</option>
        <option value="debate">Debate</option>
      </select>
    </div>

    <div style="margin-top:10px;">
      <label>What Happened (mandatory)</label>
      <textarea name="whatHappened" id="whatHappened" rows="3" placeholder="2–4 lines में क्या हुआ?" required></textarea>
    </div>

    <div style="margin-top:10px;">
      <label>Sources / References (mandatory)</label>
      <textarea name="sources" id="sources" rows="3" placeholder="Links / documents / official statements" required></textarea>
    </div>

    <div style="margin-top:10px;">
      <label>Background (optional but counts)</label>
      <textarea name="background" id="background" rows="3" placeholder="Context / past events / why it matters"></textarea>
    </div>

    <!-- BYTES -->
    <div class="panel">
      <b>Bytes (Speaker + Designation)</b>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-top:8px;">
        <div style="font-size:12px;opacity:.75;">
          Multiple bytes जोड़ सकते हैं. Transcript AI generate करेगा.
        </div>
        <button type="button" class="btn" id="addByteBtn">+ Add Byte</button>
      </div>

      <div id="bytesWrap" style="margin-top:10px;"></div>
    </div>

    <!-- VISUALS -->
    <div class="panel" id="step-visuals">
      <b>Visuals</b>
      <div class="muted">B-roll / archive / location visuals (multiple rows)</div>

      <div id="visuals-wrap"></div>

      <div style="margin-top:8px;">
        <button type="button" id="add-visual">+ Add Visual</button>
      </div>
    </div>

    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
      <button id="btnGenerate" type="submit" class="primary" onclick="generateDigiPack(event)" disabled>
        Generate DIGI_PACK
      </button>

      <button type="button" class="secondary" onclick="clearUI()">Clear</button>

      <span id="genStatus" style="font-size:13px; opacity:.8;"></span>
    </div>
  </form>
<!-- Editorial Extraction : Suggestions ONLY -->
<section id="editorial-extraction" style="margin-top:16px;">
  <h3 style="margin:0 0 8px 0;">Editorial Extraction</h3>

  <div id="ee-empty" style="opacity:.7;font-size:13px;padding:10px;border:1px dashed #bbb;border-radius:10px;">
    NG_TRANSCRIPT से suggested bytes यहाँ दिखेंगे.
  </div>

  <div id="ee-list" style="display:flex;flex-direction:column;gap:10px;margin-top:10px;"></div>

  <div style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap;">
    <button type="button" id="ee-push">Push selected to Bytes</button>
    <button type="button" id="ee-clear">Discard / Clear suggestions</button>
  </div>
</section>


  <div class="panel">
    <div class="status"><b>Status:</b> <span id="ngStatus">Idle</span></div>
    <div style="margin-top:8px;"><b>Log</b></div>
    <pre id="ngLog"></pre>
  </div>

  <div class="panel">
    <div><b>Quick View</b></div>
    <div id="ngQuick">(no quick view)</div>
  </div>

  <div class="panel">
    <div><b>Response</b></div>
    <pre id="ngResponse">(no response yet)</pre>
  </div>
<div class="panel">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <b>Preview Prompt (will be sent)</b>
    <button type="button" id="copy-prompt"
      style="padding:6px 10px;border-radius:8px;border:1px solid #ccc;background:#fff;cursor:pointer;">
      Copy
    </button>
  </div>

  <textarea id="prompt-preview" readonly
    style="width:100%;min-height:160px;margin-top:8px;padding:10px;
           border:1px solid #ccc;border-radius:10px;
           font-family:ui-monospace,Consolas,monospace;
           font-size:12px;"></textarea>
</div>

<script>
  const $ = (id) => document.getElementById(id);
  let NG_BUSY = false;

  function logLine(msg) {
    const el = $("ngLog");
    if (el) el.textContent += (msg + "\n");
  }
  function setStatus(status) {
    const el = $("ngStatus");
    if (el) el.textContent = status;
  }

  function setGenStatus(txt, busy = false) {
    const btn = $("btnGenerate");
    const st = $("genStatus");
    if (btn) btn.disabled = busy;
    if (st) st.textContent = txt;
  }

  function renderResponse(data) {
    const pre = document.getElementById("ngResponse");
    if (!pre) return;
    pre.textContent = (typeof data === "string") ? data : JSON.stringify(data, null, 2);
  }

  function safeTrim(v) { return (v ?? "").toString().trim(); }

  function updatePromptPreview(promptObj) {
    const box = document.getElementById("prompt-preview");
    if (!box) return;
    box.value = JSON.stringify(promptObj, null, 2);
  }

  // ---------- FormData helpers (getAll compatible) ----------
  function collectBytes(fd) {
    const speakers = fd.getAll("byte_speaker[]").map(safeTrim);
    const designations = fd.getAll("byte_designation[]").map(safeTrim);

    const out = [];
    const n = Math.max(speakers.length, designations.length);
    for (let i = 0; i < n; i++) {
      const speaker = speakers[i] || "";
      const designation = designations[i] || "";
      if (speaker || designation) out.push({ speaker, designation });
    }
    return out;
  }

  function collectVisuals(fd) {
    const shotTypes = fd.getAll("visual_shot_type[]").map(safeTrim);
    const sources   = fd.getAll("visual_source[]").map(safeTrim);
    const whats     = fd.getAll("visual_what[]").map(safeTrim);
    const notes     = fd.getAll("visual_notes[]").map(safeTrim);

    const out = [];
    const n = Math.max(shotTypes.length, sources.length, whats.length, notes.length);
    for (let i = 0; i < n; i++) {
      const shot_type = shotTypes[i] || "";
      const source = sources[i] || "";
      const what = whats[i] || "";
      const note = notes[i] || "";
      if (shot_type || source || what || note) out.push({ shot_type, source, what, note });
    }
    return out;
  }

  function buildPromptFromForm() {
    const form = document.getElementById("digi-pack-form");
    if (!form) throw new Error("Form not found: digi-pack-form");

    const fd = new FormData(form);

    const topic = safeTrim(fd.get("topic"));
    const platform = safeTrim(fd.get("platform")) || "Digital";
    const angle = safeTrim(fd.get("angle"));

    const story_type = safeTrim(
      fd.get("story_type") ||
      fd.get("storyType") ||
      fd.get("story") ||
      fd.get("type")
    );

    const what_happened = safeTrim(fd.get("what_happened") || fd.get("whatHappened"));
    const sources = safeTrim(fd.get("sources"));
    const background = safeTrim(fd.get("background"));

    const bytes = collectBytes(fd);
    const visuals = collectVisuals(fd);

    return {
      topic,
      platform,
      angle: angle || null,
      story_type: story_type || null,
      what_happened,
      sources,
      background: background || null,
      bytes,
      visuals
    };
  }

  async function generateDigiPack(e) {
    e?.preventDefault?.();

    const genBtn = document.getElementById("btnGenerate") || document.getElementById("btn-generate");
    if (genBtn) genBtn.disabled = true;

    try {
      const promptObj = buildPromptFromForm();
      console.log("FINAL PROMPT →", promptObj);

      if (!safeTrim(promptObj.topic)) throw new Error("Topic is required.");
      if (!safeTrim(promptObj.what_happened)) throw new Error("What Happened is required.");
      if (!safeTrim(promptObj.sources)) throw new Error("Sources is required.");

      updatePromptPreview(promptObj);

      const payload = { prompt: JSON.stringify(promptObj) };

      setStatus("Calling /api/digi-pack ...");
      logLine("POST /api/digi-pack");
      logLine("Prompt chars: " + payload.prompt.length);

      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 60000);

      const res = await fetch("/api/digi-pack", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error("HTTP " + res.status + " " + t);
      }

      const data = await res.json();
      if (typeof setResponse === "function") setResponse(data);
      else renderResponse(data);

      setStatus("Done");
      logLine("Done ✅");
    } catch (err) {
      setStatus("Error");
      logLine("Error: " + (err?.message || err));
      alert(err?.message || err);
    } finally {
      if (genBtn) genBtn.disabled = false;
    }
  }

  function getVal(name) {
    const el = document.querySelector(`[name="${name}"]`);
    return el ? (el.value || "").trim() : "";
  }

  function setGenerateState(enabled, msg) {
    const btn = $("btnGenerate") || document.getElementById("btn-generate");
    if (btn) btn.disabled = !enabled;
    const s = $("genStatus");
    if (s) s.textContent = msg || "";
  }

  function validateGenerate() {
    const topic = getVal("topic");
    const ok = !!topic;
    if (!ok) { setGenerateState(false, "Topic required"); return false; }
    setGenerateState(true, "Ready");
    return true;
  }

  document.addEventListener("input", validateGenerate);
  document.addEventListener("change", validateGenerate);

  /* =========================
     /* =========================
   BYTES UI (Speaker + Designation)
========================= */
const MAX_BYTES = 8;

function byteRowTemplate(i) {
  return `
    <div class="byte-row" data-byte-row="${i}">
      <div class="row" style="grid-template-columns: 1fr 1fr auto; gap: 8px;">
        <div>
          <label>Speaker Name</label>
          <input
            type="text"
            name="byte_speaker[]"
            data-byte-field="speaker"
            placeholder="E.g., जयराम रमेश"
            autocomplete="off"
          />
        </div>
        <div>
          <label>Designation</label>
          <input
            type="text"
            name="byte_designation[]"
            data-byte-field="designation"
            placeholder="कांग्रेस नेता"
            autocomplete="off"
          />
        </div>
        <div style="display:flex;align-items:flex-end;">
          <button
            type="button"
            class="danger"
            data-remove-byte="${i}"
            title="Remove this byte"
          >Remove</button>
        </div>
      </div>
    </div>
  `;
}

function initBytesUI() {
  // ✅ prevent double init
  if (window.__NG_BYTES_INIT_DONE) return;
  window.__NG_BYTES_INIT_DONE = true;

  // ✅ FIX: your real IDs (from your console)
  const wrap = document.getElementById("bytesWrap");
  const addBtn = document.getElementById("addByteBtn");
  if (!wrap || !addBtn) {
    console.warn("[BYTES] Missing bytesWrap/addByteBtn", { wrap: !!wrap, addBtn: !!addBtn });
    return;
  }

  // ✅ ensure button is usable
  addBtn.disabled = false;

  function getCount() {
    return wrap.querySelectorAll("[data-byte-row]").length;
  }

  function updateRemoveButtonsState() {
    const rows = Array.from(wrap.querySelectorAll("[data-byte-row]"));
    const disable = rows.length <= 1;

    rows.forEach((row) => {
      const btn = row.querySelector("[data-remove-byte]");
      if (!btn) return;

      btn.disabled = disable;
      btn.style.opacity = disable ? "0.5" : "1";
      btn.style.cursor = disable ? "not-allowed" : "pointer";
      btn.title = disable ? "At least 1 byte is required" : "Remove this byte";
    });
  }

  function renumber() {
    const rows = Array.from(wrap.querySelectorAll("[data-byte-row]"));
    rows.forEach((row, idx) => {
      const n = idx + 1;
      row.setAttribute("data-byte-row", String(n));

      const btn = row.querySelector("[data-remove-byte]");
      if (btn) btn.setAttribute("data-remove-byte", String(n));
    });

    updateRemoveButtonsState();
  }

  function addByteRow() {
    const n = getCount() + 1;
    if (typeof MAX_BYTES !== "undefined" && n > MAX_BYTES) return;

    // assumes byteRowTemplate(n) exists and creates:
    // - a container with data-byte-row
    // - inputs name="byte_speaker[]" and name="byte_designation[]"
    // - a remove button having data-remove-byte
    wrap.insertAdjacentHTML("beforeend", byteRowTemplate(n));
    renumber();
  }

  // ✅ ensure 1st row exists
  if (getCount() === 0) addByteRow();

  // ✅ expose helpers for pushToBytes()
  window.NG_addByteRow = addByteRow;
  window.NG_getByteCount = getCount;

  // ✅ add row button
  addBtn.addEventListener("click", (e) => {
    e.preventDefault();
    addByteRow();
  });

  // ✅ remove (event delegation)
  wrap.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-remove-byte]");
    if (!btn) return;

    e.preventDefault();

    const row = btn.closest("[data-byte-row]");
    if (!row) return;

    if (getCount() <= 1) return; // keep minimum 1 row
    row.remove();
    renumber();
  });

  // initial state
  renumber();
}


  /* =========================
     VISUALS UI (FormData.getAll compatible)
  ========================= */
  function visualRowTemplate(i) {
    return `
      <div class="visual-row" data-visual-row="${i}" style="border:1px solid #e6e6e6;border-radius:12px;padding:10px;margin-top:10px;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
          <div class="v-row-label" style="font-weight:600;">Visual ${i}</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button type="button" data-action="gen-visual">Generate</button>
            <button type="button" data-action="clear-visual">Clear</button>
            <button type="button" data-action="remove-visual">Remove</button>
          </div>
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px;">
          <div>
            <label style="font-size:12px;opacity:.8;display:block;margin-bottom:4px;">Shot Type</label>
            <select name="visual_shot_type[]" style="width:100%;padding:10px;border:1px solid #ccc;border-radius:8px;">
              <option value="BROLL">B-roll</option>
              <option value="ARCHIVE">Archive</option>
              <option value="LOCATION">Location</option>
              <option value="GRAPHIC">Graphic</option>
              <option value="SCREEN">Screen</option>
            </select>
          </div>

          <div>
            <label style="font-size:12px;opacity:.8;display:block;margin-bottom:4px;">Source</label>
            <input type="text" name="visual_source[]" placeholder="Reporter / Agency / Archive"
              style="width:100%;padding:10px;border:1px solid #ccc;border-radius:8px;" />
          </div>
        </div>

        <div style="margin-top:8px;">
          <label style="font-size:12px;opacity:.8;display:block;margin-bottom:4px;">What to show</label>
          <input type="text" name="visual_what[]" placeholder="E.g., दुकान पर छापा, सील पैक, अस्पताल, लैब, दस्तावेज़"
            style="width:100%;padding:10px;border:1px solid #ccc;border-radius:8px;" />
        </div>

        <div style="margin-top:8px;">
          <label style="font-size:12px;opacity:.8;display:block;margin-bottom:4px;">Notes (optional)</label>
          <input type="text" name="visual_notes[]" placeholder="E.g., 3-5 sec, blur face, avoid brand"
            style="width:100%;padding:10px;border:1px solid #ccc;border-radius:8px;" />
        </div>
      </div>
    `;
  }

  function initVisualsUI() {
    const wrap = document.getElementById("visuals-wrap");
    const addBtn = document.getElementById("add-visual");
    if (!wrap || !addBtn) return;

    function getCount() {
      return wrap.querySelectorAll("[data-visual-row]").length;
    }

    function renumber() {
      const rows = Array.from(wrap.querySelectorAll("[data-visual-row]"));
      rows.forEach((row, idx) => {
        row.setAttribute("data-visual-row", String(idx + 1));
        const label = row.querySelector(".v-row-label");
        if (label) label.textContent = "Visual " + (idx + 1);
        const rm = row.querySelector('button[data-action="remove-visual"]');
        if (rm) rm.disabled = (idx === 0);
      });
    }

    function addVisualRow() {
      const n = getCount() + 1;
      wrap.insertAdjacentHTML("beforeend", visualRowTemplate(n));
      renumber();
    }

    if (getCount() === 0) addVisualRow();
    addBtn.addEventListener("click", addVisualRow);

    // event delegation (ONLY visuals actions)
    wrap.addEventListener("click", (e) => {
      const btn = e.target.closest('button[data-action]');
      if (!btn) return;

      const row = btn.closest("[data-visual-row]");
      if (!row) return;

      const action = btn.getAttribute("data-action");

      if (action === "remove-visual") {
        if (getCount() <= 1) return;
        row.remove();
        renumber();
        return;
      }

      if (action === "clear-visual") {
        row.querySelectorAll("input").forEach(i => (i.value = ""));
        const sel = row.querySelector('select[name="visual_shot_type[]"]');
        if (sel) sel.value = "BROLL";
        return;
      }

      if (action === "gen-visual") {
        const sel  = row.querySelector('select[name="visual_shot_type[]"]');
        const what = row.querySelector('input[name="visual_what[]"]');
        const src  = row.querySelector('input[name="visual_source[]"]');

        const type = sel ? sel.value : "BROLL";

        if (what && !what.value.trim()) {
          what.value =
            type === "ARCHIVE"  ? "फाइल फुटेज / पुरानी क्लिप" :
            type === "LOCATION" ? "लोकेशन शॉट / साइनबोर्ड / एरिया विजुअल" :
            type === "GRAPHIC"  ? "टाइमलाइन / नंबर / मैप प्लेट" :
            type === "SCREEN"   ? "वेबसाइट/दस्तावेज़ स्क्रीन" :
                                  "B-roll (जांच/रिएक्शन/डिटेल शॉट)";
        }
        if (src && !src.value.trim()) src.value = "Reporter/Archive";
        return;
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    validateGenerate();
    initBytesUI();
    initVisualsUI();
  });

  ;(function initPromptPreviewCopy() {
    const btn = document.getElementById("copy-prompt");
    const box = document.getElementById("prompt-preview");
    if (!btn || !box) return;

    btn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(box.value || "");
        if (typeof logLine === "function") logLine("Preview prompt copied ✅");
      } catch {
        box.focus();
        box.select();
        document.execCommand("copy");
        if (typeof logLine === "function") logLine("Preview prompt copied (fallback) ✅");
      }
    });
  })();
</script>

<script>
/* === Editorial Extraction : Suggestions Panel + Transcript Auto-Ingest (Clean V3) === */

  "use strict";

  // ---------------- utils ----------------
  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, (m) => ({
      "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
    }[m]));
  }
  function norm(s) { return String(s ?? "").replace(/\s+/g, " ").trim(); }
  function normKey(s) {
    return norm(s).toLowerCase()
      .replace(/[“”"']/g, "")
      .replace(/[^\p{L}\p{N}\s]/gu, "")
      .replace(/\s+/g, " ")
      .trim();
  }

  // optional speaker→designation map
  window.__NG_SPEAKER_MAP = window.__NG_SPEAKER_MAP || {
    "किरण रिजिजू": "केंद्रीय मंत्री",
    "जयराम रमेश": "कांग्रेस नेता"
  };

  // ---------------- extraction helpers ----------------
  function guessSpeakerFromText(text) {
    const t = norm(text);

    // "नाम (पद): बयान..."
    const m2 = t.match(/^(.{2,40})\s*\((.{2,40})\)\s*[:：]\s*(.+)$/);
    if (m2) return { speaker: norm(m2[1]), designation: norm(m2[2]), text: norm(m2[3]) };

    // "नाम: बयान..."
    const m = t.match(/^([^:：]{2,40})\s*[:：]\s*(.+)$/);
    if (m) return { speaker: norm(m[1]), text: norm(m[2]) };

    // "नाम ने कहा/बताया... (कि) ..."
    const m3 = t.match(
      /^([^\s:：]{2,20}(?:\s+[^\s:：]{2,20}){0,2})\s+(?:ने\s+(?:कहा|बोले|बताया|आरोप\s+लगाया|दावा\s+किया|तंज\s+कसा)|का\s+कहना\s+है)\s*(?:कि\s*)?(.+)$/
    );
    if (m3) {
      const sp = norm(m3[1]);
      const rest = norm(m3[2] || "");
      if (sp && !/^(उन्होंने|उसने|हमने|आपने|इन्होंने|उनका|उसका)$/u.test(sp)) {
        return { speaker: sp, text: rest || t };
      }
    }

    return { text: t };
  }

  function scoreLine(line) {
    const t = (line.text || "").trim();
    const len = t.length;
    let score = 0;

    if (len >= 18 && len <= 140) score += 3;
    else if (len >= 10 && len <= 220) score += 1.5;
    else if (len < 8) score -= 4;
    else score -= 0.2;

    if (line.speaker) score += 1.6;
    if (/[“”"']/.test(t)) score += 1.2;
    if (/[?!]/.test(t)) score += 0.4;

    if (/(कहा|बोले|बताया|स्पष्ट|साफ|जवाब|तैयार|आरोप|तंज|सरकार|विपक्ष|जांच|सवाल|चुनाव|संसद|देश|जनता)/.test(t)) score += 2;
    if (/(नहीं|गलत|झूठ|सबूत|कार्रवाई|मांग|इस्तीफा|हमला|बचाव)/.test(t)) score += 1;
    if (/[0-9०-९]/.test(t)) score += 0.6;

    if (/(धन्यवाद|नमस्कार|स्वागत|आप देख रहे|देखिए|दोस्तों|चलिये|अब हम)/.test(t)) score -= 4;

    return score;
  }

  function extractReverieText(root) {
    if (!root) return "";
    if (typeof root === "string") return root.trim();

    const cands = [
      root.display_text, root.text,
      root.result?.display_text, root.result?.text,
      root.output?.display_text, root.output?.text,
      root.data?.display_text, root.data?.text,
      root.response?.display_text, root.response?.text,
      root.success && root.text ? root.text : null
    ];
    for (const c of cands) if (typeof c === "string" && c.trim()) return c.trim();
    return "";
  }

  function mapArrToLines(arr) {
    const out = [];
    for (const it of arr || []) {
      let txt = "";
      if (typeof it === "string") txt = it;
      else if (it && typeof it === "object") {
        txt = it.text || it.transcript || it.utterance || it.sentence || it.content || it.line || "";
      }
      txt = norm(txt);
      if (!txt) continue;

      const g = guessSpeakerFromText(txt);
      let speaker = norm(g.speaker || it?.speaker || it?.name || "");
      let designation = norm(g.designation || it?.designation || it?.title || "");
      let text = norm(g.text || txt);

      if (speaker && !designation) designation = window.__NG_SPEAKER_MAP[speaker] || "";

      out.push({ speaker, designation, text });
    }
    return out;
  }

  function looksLikeTranscriptArr(arr) {
    let hits = 0, totalLen = 0;
    for (const it of arr || []) {
      const txt = (typeof it === "string")
        ? it
        : (it?.text || it?.transcript || it?.utterance || it?.sentence || it?.content || it?.line);
      if (typeof txt === "string" && txt.trim()) {
        hits++;
        totalLen += txt.trim().length;
      }
    }
    const avg = hits ? totalLen / hits : 0;
    return hits >= 2 && avg >= 10;
  }

  function collectCandidateLines(root, opts) {
    const maxNodes = Number(opts?.maxNodes || 9000);

    // Prefer full text
    const fullText = extractReverieText(root);
    if (fullText) {
      const normalized = String(fullText)
        .replace(/\r/g, "\n")
        .replace(/[ \t]+/g, " ")
        .replace(/\n{3,}/g, "\n\n")
        .replace(/([।.?!])\s+/g, "$1\n")
        .trim();

      const parts = normalized
        .split("\n")
        .map(s => (s || "").trim())
        .filter(s => s.length >= 12)
        .slice(0, 80);

      return parts.map(p => {
        const g = guessSpeakerFromText(p);
        const speaker = norm(g.speaker || "");
        const designation = norm(g.designation || (speaker ? (window.__NG_SPEAKER_MAP[speaker] || "") : ""));
        const text = norm(g.text || p);
        return { speaker, designation, text };
      });
    }

    // Direct arrays
    const directCandidates = [];
    if (Array.isArray(root?.segments)) directCandidates.push(root.segments);
    if (Array.isArray(root?.result?.segments)) directCandidates.push(root.result.segments);
    if (Array.isArray(root?.data?.segments)) directCandidates.push(root.data.segments);
    if (Array.isArray(root?.utterances)) directCandidates.push(root.utterances);
    if (Array.isArray(root?.sentences)) directCandidates.push(root.sentences);
    if (Array.isArray(root?.results)) directCandidates.push(root.results);

    for (const arr of directCandidates) {
      if (Array.isArray(arr) && looksLikeTranscriptArr(arr)) return mapArrToLines(arr);
    }

    // BFS scan for best transcript-like array
    const queue = [root];
    let nodes = 0;
    const arrays = [];

    while (queue.length && nodes < maxNodes) {
      const v = queue.shift();
      nodes++;
      if (!v) continue;

      if (Array.isArray(v)) {
        if (looksLikeTranscriptArr(v)) arrays.push(v);
        for (const it of v) if (it && typeof it === "object") queue.push(it);
        continue;
      }
      if (typeof v === "object") {
        for (const k in v) {
          if (!Object.prototype.hasOwnProperty.call(v, k)) continue;
          const it = v[k];
          if (it && typeof it === "object") queue.push(it);
        }
      }
    }

    return mapArrToLines(arrays[0] || []);
  }

  function pickBestLines(lines, min = 6, max = 10) {
    const seenText = new Set();
    const bestPerSpeaker = new Map();
    const rest = [];

    for (const ln of (lines || [])) {
      const tKey = normKey(ln.text);
      if (!tKey || tKey.length < 8) continue;
      if (seenText.has(tKey)) continue;
      seenText.add(tKey);

      const scored = { ...ln, __score: scoreLine(ln) };
      if (scored.__score < -2.5) continue;

      const sp = norm(scored.speaker);
      if (sp) {
        const prev = bestPerSpeaker.get(sp);
        if (!prev || scored.__score > prev.__score) bestPerSpeaker.set(sp, scored);
        else rest.push(scored);
      } else {
        rest.push(scored);
      }
    }

    const picked = Array.from(bestPerSpeaker.values()).sort((a, b) => b.__score - a.__score);
    rest.sort((a, b) => b.__score - a.__score);

    for (const r of rest) {
      if (picked.length >= max) break;
      picked.push(r);
    }
    return picked.slice(0, Math.max(min, Math.min(max, picked.length)));
  }

  // ---------------- BYTES helpers (used by push) ----------------
  function getAddByteButton() {
    return (
      document.getElementById("addByteBtn") ||
      document.getElementById("add-byte") ||
      document.querySelector('[data-action="add-byte"]')
    );
  }

  function getByteFields() {
    const wrap = document.getElementById("bytesWrap") || document;
    const speakers = [...wrap.querySelectorAll('input[name="byte_speaker[]"]')];
    const desigs   = [...wrap.querySelectorAll('input[name="byte_designation[]"]')];
    const texts    = [...wrap.querySelectorAll('textarea[name="byte_text[]"], input[name="byte_text[]"]')];
    return { wrap, speakers, desigs, texts };
  }

  function ensureByteRows(targetCount) {
    const addBtn = getAddByteButton();
    if (!addBtn) return;

    let safety = 40;
    while (safety-- > 0) {
      const { speakers } = getByteFields();
      if (speakers.length >= targetCount) break;

      if (typeof window.NG_addByteRow === "function") window.NG_addByteRow();
      else addBtn.click();
    }
  }

  function existingByteSet() {
    const { speakers, desigs, texts } = getByteFields();
    const set = new Set();
    const n = Math.max(speakers.length, desigs.length, texts.length);

    for (let i = 0; i < n; i++) {
      const sp = normKey(speakers[i]?.value || "");
      const ds = normKey(desigs[i]?.value || "");
      const tx = normKey(texts[i]?.value || "");
      if (sp || ds || tx) set.add(`${sp}|${ds}|${tx}`);
    }
    return set;
  }

  function findFirstEmptySlot() {
    const { speakers, desigs, texts } = getByteFields();
    const n = Math.max(speakers.length, desigs.length, texts.length);

    for (let i = 0; i < n; i++) {
      const sp = norm(speakers[i]?.value || "");
      const ds = norm(desigs[i]?.value || "");
      const tx = norm(texts[i]?.value || "");
      if (!sp && !ds && !tx) return i;
      if (!sp && !ds) return i;
    }
    return n;
  }

  function fillSlot(i, item) {
    ensureByteRows(i + 1);
    const f = getByteFields();
    if (f.speakers[i]) f.speakers[i].value = item?.speaker || "";
    if (f.desigs[i])   f.desigs[i].value   = item?.designation || "";
    if (f.texts[i])    f.texts[i].value    = item?.text || "";
  }

  // ---------------- UI init ----------------
function initEditorialExtraction() {
  if (window.__NG_EE_INIT_DONE) return;
  window.__NG_EE_INIT_DONE = true;

  const eeList  = document.getElementById("ee-list");
  const eeEmpty = document.getElementById("ee-empty");
  const btnPush = document.getElementById("ee-push");
  const btnClear= document.getElementById("ee-clear");

  if (!eeList || !btnPush || !btnClear) {
    console.warn("[EE] Missing ee-list/ee-push/ee-clear");
    return;
  }

  let suggestions = [];

  function showEmpty(on) {
    if (!eeEmpty) return;
    eeEmpty.style.display = on ? "block" : "none";
  }

  function updateButtons() {
    const total   = eeList.querySelectorAll('input[type="checkbox"][data-i]').length;
    const checked = eeList.querySelectorAll('input[type="checkbox"][data-i]:checked').length;
    btnPush.disabled  = (checked === 0);
    btnClear.disabled = (total === 0);
  }

  // --- Bytes helpers (bulletproof, DOM-driven) ---
  function bytesWrapEl() {
    return document.getElementById("bytesWrap") || document.getElementById("bytes-wrap");
  }

  function addByteButtonEl() {
    return (
      document.getElementById("addByteBtn") ||
      document.getElementById("add-byte") ||
      document.getElementById("addByte")
    );
  }

  function getByteInputs() {
    const wrap = bytesWrapEl();
    if (!wrap) return { sp: [], ds: [], tx: [] };
    const sp = Array.from(wrap.querySelectorAll('input[name="byte_speaker[]"]'));
    const ds = Array.from(wrap.querySelectorAll('input[name="byte_designation[]"]'));
    const tx = Array.from(wrap.querySelectorAll('textarea[name="byte_text[]"], input[name="byte_text[]"]'));
    return { sp, ds, tx };
  }

  function ensureByteRows(minRows) {
    let { sp, ds } = getByteInputs();
    let n = Math.max(sp.length, ds.length);
    let safety = 0;

    while (n < minRows && safety++ < 30) {
      if (typeof window.NG_addByteRow === "function") {
        window.NG_addByteRow();
      } else {
        const addBtn = addByteButtonEl();
        if (addBtn) addBtn.click();
        else break;
      }
      ({ sp, ds } = getByteInputs());
      n = Math.max(sp.length, ds.length);
    }
    return n;
  }

  function findFirstEmptySlot() {
    const { sp, ds } = getByteInputs();
    const n = Math.max(sp.length, ds.length);
    for (let i = 0; i < n; i++) {
      const a = (sp[i]?.value || "").trim();
      const b = (ds[i]?.value || "").trim();
      if (!a && !b) return i;
    }
    return n; // append
  }

  function normKeyLocal(s) {
    return (s || "")
      .toString()
      .trim()
      .replace(/\s+/g, " ")
      .toLowerCase();
  }

  function existingByteSet() {
    const set = new Set();
    const { sp, ds, tx } = getByteInputs();
    const n = Math.max(sp.length, ds.length, tx.length);
    for (let i = 0; i < n; i++) {
      const speaker = (sp[i]?.value || "").trim();
      const desig   = (ds[i]?.value || "").trim();
      const text    = (tx[i]?.value || "").trim();
      if (!speaker && !desig && !text) continue;
      set.add(`${normKeyLocal(speaker)}|${normKeyLocal(desig)}|${normKeyLocal(text)}`);
    }
    return set;
  }

  // ✅ return true/false
  function fillSlot(slotIndex, item) {
    ensureByteRows(slotIndex + 1);

    const { sp, ds, tx } = getByteInputs();
    if (!sp[slotIndex] || !ds[slotIndex]) return false;

    const speaker = (item?.speaker || "").toString().trim();
    const desig   = (item?.designation || "").toString().trim();
    const text    = (item?.text || "").toString().trim();

    if (!speaker || !desig) return false;

    const spWas = (sp[slotIndex].value || "").trim();
    const dsWas = (ds[slotIndex].value || "").trim();

    // don't overwrite
    if (spWas || dsWas) return false;

    sp[slotIndex].value = speaker;
    ds[slotIndex].value = desig;

    if (tx && tx[slotIndex] && !((tx[slotIndex].value || "").trim()) && text) {
      tx[slotIndex].value = text;
    }

    // trigger input events
    try { sp[slotIndex].dispatchEvent(new Event("input", { bubbles: true })); } catch(e){}
    try { ds[slotIndex].dispatchEvent(new Event("input", { bubbles: true })); } catch(e){}
    if (tx && tx[slotIndex]) { try { tx[slotIndex].dispatchEvent(new Event("input", { bubbles: true })); } catch(e){} }

    return true;
  }

  function render(list) {
    suggestions = Array.isArray(list) ? list : [];

    // ✅ keep suggestions in memory for pushToBytes
    window.__NG_EE_SUGGEST = suggestions;
    window.__NG_EE_SUGGESTIONS = suggestions; // backward alias

    eeList.innerHTML = "";

    if (!suggestions.length) {
      showEmpty(true);
      btnPush.disabled = true;
      btnClear.disabled = true;
      return;
    }

    showEmpty(false);

    suggestions.forEach((b, i) => {
      const speaker = esc(b.speaker || "Unknown");
      const desig   = esc(b.designation || "");
      const text    = esc(b.text || "");

      const card = document.createElement("label");
      card.style.cssText =
        "border:1px solid #ddd;border-radius:12px;padding:10px;display:block;margin:10px 0;cursor:pointer;";

      card.innerHTML = `
        <div style="display:flex;gap:10px;align-items:flex-start;">
          <input type="checkbox" data-i="${i}" style="margin-top:3px;">
          <div style="flex:1;">
            <div style="font-weight:700;">${speaker}</div>
            <div style="opacity:.75;font-size:12px;margin-top:2px;">${desig}</div>
            <div style="margin-top:8px;line-height:1.35;">${text}</div>
          </div>
        </div>
      `;
      eeList.appendChild(card);
    });

    updateButtons();
  }

  function clearAll() {
    render([]);
  }

  function getCheckedIndices() {
    return [...eeList.querySelectorAll('input[type="checkbox"][data-i]:checked')]
      .map(cb => Number(cb.getAttribute("data-i")))
      .filter(n => Number.isFinite(n) && n >= 0);
  }

  function pushToBytes() {
    const idxs = getCheckedIndices();
    if (!idxs.length) return;

    const dupeSet = existingByteSet();
    const pushedRun = new Set();
    let pushed = 0;

    for (const idx of idxs) {
      const item = suggestions[idx];
      if (!item) continue;

      const speaker = (item.speaker || "").toString().trim();
      const desig   = (item.designation || "").toString().trim();
      const text    = (item.text || "").toString().trim();

      const key = `${normKeyLocal(speaker)}|${normKeyLocal(desig)}|${normKeyLocal(text)}`;

      // ✅ no duplicates: already in bytes OR already pushed in this click
      if (dupeSet.has(key) || pushedRun.has(key)) continue;

      // find next empty slot and ensure rows
      const slot = findFirstEmptySlot();
      ensureByteRows(slot + 1);

      const ok = fillSlot(slot, { speaker, designation: desig, text });

      // ✅ only if filled successfully: uncheck + count + add to sets
      if (ok) {
        const cb = eeList.querySelector(`input[type="checkbox"][data-i="${idx}"]`);
        if (cb) cb.checked = false;

        dupeSet.add(key);
        pushedRun.add(key);
        pushed++;
      }
    }

    if (pushed) console.log("[EE] Pushed to Bytes:", pushed);
    updateButtons();
  }

  // bind once
  if (!window.__NG_EE_WIRED) {
    window.__NG_EE_WIRED = true;

    eeList.addEventListener("change", updateButtons);

    btnPush.addEventListener("click", (e) => {
      e.preventDefault();
      pushToBytes();
    });

    btnClear.addEventListener("click", (e) => {
      e.preventDefault();
      clearAll();
    });
  }

  // expose renderer
  window.NG_setEditorialSuggestions = render;

  // initial empty
  render([]);
  console.log("[EE] initEditorialExtraction READY");
}

  // ---------------- ingest + hook NG_TRANSCRIPT ----------------
  window.NG_ingestTranscript = function (reverieJsonOrText) {
    const rawLines = collectCandidateLines(reverieJsonOrText, { maxNodes: 9000 });
    const best = pickBestLines(rawLines, 6, 10).map(x => ({
      speaker: x.speaker || "",
      designation: x.designation || "",
      text: x.text || ""
    }));

    // ✅ keep latest suggestions in memory (for pushToBytes fallback)
window.__NG_EE_SUGGEST = Array.isArray(best) ? best : [];

if (typeof window.NG_setEditorialSuggestions === "function") {
  window.NG_setEditorialSuggestions(best);
}

// ✅ after render, ensure push button state is correct
syncEePushBtn();

console.log("[EE] Transcript → suggestions:", best.length);
return best;


  (function hookTranscriptSetter() {
    if (window.__NG_TRANSCRIPT_HOOKED) return;
    window.__NG_TRANSCRIPT_HOOKED = true;

    let _t = window.NG_TRANSCRIPT;
    let _lastSig = "";

    function sigOf(v) {
      try {
        if (v == null) return "";
        if (typeof v === "string") return "str:" + v.slice(0, 120);
        return "obj:" + JSON.stringify(v).slice(0, 240);
      } catch {
        return "unk";
      }
    }

    function ingestSoon(v, reason) {
      const sig = sigOf(v);
      if (!sig || sig === _lastSig) return;
      _lastSig = sig;

      setTimeout(() => {
        try {
          if (typeof window.NG_ingestTranscript === "function") window.NG_ingestTranscript(v);
        } catch (e) {
          console.error("[EE] ingest error:", e);
        }
      }, 0);

      console.log("[EE] NG_TRANSCRIPT ingest (" + reason + ")");
    }

    try {
      Object.defineProperty(window, "NG_TRANSCRIPT", {
        configurable: true,
        get: function () { return _t; },
        set: function (v) { _t = v; ingestSoon(v, "setter"); }
      });
    } catch (e) {
      console.warn("[EE] NG_TRANSCRIPT hook failed (non-configurable).", e);
    }

    if (_t) ingestSoon(_t, "boot");
  })();

  // ---------------- Transcript JSON Loader ----------------
  (function initTranscriptJsonLoader() {
    const LS_KEY = "NG_REVERIE_TRANSCRIPT_JSON_V1";
    function $(id){ return document.getElementById(id); }

    function extractTranscriptText(obj) {
      if (typeof obj === "string") return obj;

      if (obj && typeof obj.display_text === "string" && obj.display_text.trim()) return obj.display_text;
      if (obj && typeof obj.text === "string" && obj.text.trim()) return obj.text;

      const cands = [obj?.result, obj?.output, obj?.data, obj?.transcript, obj?.transcription].filter(Boolean);
      for (const c of cands) {
        if (typeof c?.display_text === "string" && c.display_text.trim()) return c.display_text;
        if (typeof c?.text === "string" && c.text.trim()) return c.text;
      }

      const segs =
        obj?.segments || obj?.result?.segments || obj?.output?.segments || obj?.data?.segments ||
        obj?.utterances || obj?.result?.utterances || obj?.items;

      if (Array.isArray(segs) && segs.length) {
        const parts = segs.map(s =>
          (typeof s?.display_text === "string" && s.display_text.trim()) ? s.display_text :
          (typeof s?.text === "string" && s.text.trim()) ? s.text :
          (typeof s?.utterance === "string" && s.utterance.trim()) ? s.utterance :
          ""
        ).filter(Boolean);
        if (parts.length) return parts.join("\n");
      }

      return "";
    }

    function loadFromTextarea() {
      const ta = $("ta-transcript-json");
      if (!ta) return;

      const raw = (ta.value || "").trim();
      if (!raw) return;

      try { localStorage.setItem(LS_KEY, raw); } catch {}

      let parsed;
      try { parsed = JSON.parse(raw); } catch { parsed = raw; }

      const text = extractTranscriptText(parsed) || (typeof parsed === "string" ? parsed : "");
      window.NG_TRANSCRIPT = text; // ✅ sets extracted text
      console.log("[TL] NG_TRANSCRIPT set. chars:", (text || "").length);
    }

    function boot() {
      const ta = $("ta-transcript-json");
      const btn = $("btn-load-transcript-json");

      try {
        const saved = localStorage.getItem(LS_KEY);
        if (ta && saved && !ta.value.trim()) ta.value = saved;
      } catch {}

      if (btn && !btn.__NG_BOUND) {
        btn.__NG_BOUND = true;
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          loadFromTextarea();
        });
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", boot, { once: true });
    } else {
      boot();
    }
})();  // ✅ close Transcript Loader IIFE


  // ---------------- export global + auto init ----------------
  window.initEditorialExtraction = initEditorialExtraction;

  if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initEditorialExtraction, { once: true });
} else {
  initEditorialExtraction();
}


</script>

<script>
/* Patch Override ... */



</body>
</html>