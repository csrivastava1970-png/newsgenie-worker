;(() => {
  if (window.__NG_DEFAULT_QUOTE_TEMPLATE_V10__) return;
  window.__NG_DEFAULT_QUOTE_TEMPLATE_V10__ = true;

  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

  function findAddBtn() {
    return qsa("button").find(b => /\badd byte\b/i.test((b.textContent||"").trim()));
  }

  function findBytesPanel(addBtn) {
    let el = addBtn;
    for (let i=0;i<16 && el;i++){
      const t = el.innerText || "";
      if (/\bBytes\b/i.test(t) && /Final Bytes/i.test(t)) return el;
      el = el.parentElement;
    }
    return addBtn.parentElement || document.body;
  }

  function ensureDefaultQuoteUI(panel){
    if (panel.querySelector("#ng-default-quote-template")) return;

    const defDesig = qsa("input", panel).find(i => /default designation/i.test(i.placeholder||""));
    const anchor = defDesig ? (defDesig.closest("div") || defDesig.parentElement) : panel;

    const wrap = document.createElement("div");
    wrap.style.marginTop = "10px";

    const lab = document.createElement("div");
    lab.textContent = "Default Quote (auto-fill)";
    lab.style.fontSize = "12px";
    lab.style.opacity = "0.85";
    lab.style.marginBottom = "6px";

    const ta = document.createElement("textarea");
    ta.id = "ng-default-quote-template";
    ta.rows = 2;
    ta.placeholder = "यहाँ default byte/quote लिखें (नई rows में auto-fill होगा)";
    ta.style.width = "100%";
    ta.style.padding = "10px";
    ta.style.border = "1px solid #ccc";
    ta.style.borderRadius = "10px";

    wrap.appendChild(lab);
    wrap.appendChild(ta);

    // insert right after Default Designation block if found, else append in panel
    if (anchor && anchor.parentElement) {
      anchor.parentElement.insertBefore(wrap, anchor.nextSibling);
    } else {
      panel.appendChild(wrap);
    }
  }

  function getDefaultQuote(panel){
    const t = panel.querySelector("#ng-default-quote-template");
    return t ? (t.value || "").trim() : "";
  }

  function fillLatestRowQuote(panel){
    // find quote field in the last created row: use the Text/Quote label area
    const rows = qsa("button", panel).filter(b => (b.textContent||"").trim().toLowerCase()==="remove");
    // locate last Remove button's nearest container and search textarea/input inside it
    const lastRm = rows[rows.length-1];
    if (!lastRm) return;

    const rowBox = lastRm.closest("div")?.parentElement || lastRm.closest("div") || panel;
    const qCtl = qsa("textarea,input", rowBox)
      .filter(x => x.tagName==="TEXTAREA" || (x.tagName==="INPUT" && ((x.type||"text")==="text")))
      .find(x => /quote|बाइट|actual/i.test((x.placeholder||"") + " " + (x.name||"") + " " + (x.id||"")));

    if (!qCtl) return;

    const dq = getDefaultQuote(panel);
    if (dq && !(qCtl.value||"").trim()) qCtl.value = dq;

    // ensure visible
    qCtl.style.display = "block";
    qCtl.style.visibility = "visible";
    qCtl.style.opacity = "1";
    qCtl.style.minHeight = (qCtl.tagName==="TEXTAREA") ? "68px" : "44px";
  }

  function boot(){
    const addBtn = findAddBtn();
    if (!addBtn) return;

    const panel = findBytesPanel(addBtn);
    ensureDefaultQuoteUI(panel);

    // Hook add button: after click, auto-fill quote (once)
    addBtn.addEventListener("click", () => {
      setTimeout(() => fillLatestRowQuote(panel), 200);
      setTimeout(() => fillLatestRowQuote(panel), 600);
    }, {capture:true});

    // Also try once on load (if a row already exists)
    setTimeout(() => fillLatestRowQuote(panel), 1200);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
/* NG_FINAL_BYTES_DBLCLICK_V11_START */
;(() => {
  if (window.__NG_FINAL_BYTES_DBLCLICK_V11__) return;
  window.__NG_FINAL_BYTES_DBLCLICK_V11__ = true;

  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

  function findAddBtn(){
    return qsa("button").find(b => /\badd byte\b/i.test((b.textContent||"").trim()));
  }

  function findBytesPanel(addBtn){
    let el = addBtn;
    for(let i=0;i<18 && el;i++){
      const t = el.innerText || "";
      if (/\bBytes\b/i.test(t) && /Final Bytes/i.test(t)) return el;
      el = el.parentElement;
    }
    return addBtn.parentElement || document.body;
  }

  function rowRootFrom(node){
    let el = node;
    for(let i=0;i<12 && el;i++){
      const t = (el.innerText||"");
      const hasRemove = qsa("button", el).some(b => (b.textContent||"").trim().toLowerCase()==="remove");
      const hasLabels = /speaker name/i.test(t) && /designation/i.test(t) && /text\s*\/\s*quote/i.test(t);
      if (hasRemove && hasLabels) return el;
      el = el.parentElement;
    }
    return node.closest("div") || document.body;
  }

  function extractRowData(row){
    const inputs = qsa("input", row)
      .filter(i => (i.type||"text")==="text")
      .filter(i => !/default speaker/i.test(i.placeholder||""))
      .filter(i => !/default designation/i.test(i.placeholder||""));

    const speaker = (inputs[0]?.value || "").trim();
    const designation = (inputs[1]?.value || "").trim();

    const quoteCtl =
      qsa("textarea,input", row)
        .filter(x => x.id !== "bytesJSONOut" && x.id !== "ng-byte-draft-text")
        .find(x => /quote|बाइट|actual/i.test((x.placeholder||"") + " " + (x.name||"") + " " + (x.id||"")));

    const text = ((quoteCtl && quoteCtl.value) ? quoteCtl.value : "").trim();
    return { speaker, designation, text };
  }

  function readBytesJSON(){
    const out = document.getElementById("bytesJSONOut");
    if (!out) return { out:null, arr:[] };

    const raw = (out.value || "").trim();
    if (!raw) return { out, arr:[] };

    try{
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return { out, arr: parsed };
      if (parsed && Array.isArray(parsed.bytes)) return { out, arr: parsed.bytes, wrap:"bytes" };
      return { out, arr: [] };
    }catch(e){
      return { out, arr: [] };
    }
  }

  function writeBytesJSON(out, arr, wrap){
    if (!out) return;
    const payload = wrap === "bytes" ? { bytes: arr } : arr;
    out.value = JSON.stringify(payload, null, 2);
  }

  function keyOf(b){
    return [b.speaker||"", b.designation||"", b.text||""].join("||").trim();
  }

  function ensureFinalBytesList(panel){
    const candidates = qsa("div", panel).filter(d => /Final Bytes/i.test(d.innerText||""));
    const box = candidates.sort((a,b) => (a.innerText||"").length - (b.innerText||"").length)[0] || panel;

    let list = box.querySelector("#ng-final-bytes-list-v11");
    if (!list){
      list = document.createElement("div");
      list.id = "ng-final-bytes-list-v11";
      list.style.marginTop = "8px";
      list.style.display = "flex";
      list.style.flexDirection = "column";
      list.style.gap = "8px";
      box.appendChild(list);
    }
    return { box, list };
  }

  function updateFinalBytesUI(panel, arr){
    const { box, list } = ensureFinalBytesList(panel);

    const headerNode = qsa("*", box).find(n => n.childElementCount===0 && /Final Bytes/i.test(n.textContent||""));
    if (headerNode) headerNode.textContent = "Final Bytes • " + arr.length;

    const emptyNode = qsa("*", box).find(n => n.childElementCount===0 && /\(No bytes yet\)/i.test(n.textContent||""));
    if (emptyNode && arr.length>0) emptyNode.textContent = "";

    list.innerHTML = "";
    arr.slice(0, 30).forEach((b) => {
      const item = document.createElement("div");
      item.style.padding = "8px 10px";
      item.style.border = "1px solid #e5e7eb";
      item.style.borderRadius = "10px";
      item.style.fontSize = "13px";
      const who = [b.speaker||"", b.designation||""].filter(Boolean).join(" • ");
      const txt = (b.text||"").replace(/\s+/g," ").slice(0, 220);
      item.textContent = (who ? (who + " — ") : "") + txt;
      list.appendChild(item);
    });
  }

  function toast(panel, msg){
    let t = panel.querySelector("#ng-toast-v11");
    if (!t){
      t = document.createElement("div");
      t.id = "ng-toast-v11";
      t.style.position = "sticky";
      t.style.bottom = "10px";
      t.style.marginTop = "10px";
      t.style.padding = "6px 10px";
      t.style.borderRadius = "10px";
      t.style.background = "#111827";
      t.style.color = "white";
      t.style.fontSize = "12px";
      t.style.display = "none";
      panel.appendChild(t);
    }
    t.textContent = msg;
    t.style.display = "inline-block";
    clearTimeout(t.__h);
    t.__h = setTimeout(() => { t.style.display = "none"; }, 900);
  }

  function boot(){
    const addBtn = findAddBtn();
    if (!addBtn) return;
    const panel = findBytesPanel(addBtn);

    panel.addEventListener("dblclick", (ev) => {
      const tgt = ev.target;
      if (!(tgt instanceof HTMLElement)) return;

      const isQuoteCtl =
        (tgt.tagName === "TEXTAREA" || tgt.tagName === "INPUT") &&
        !["bytesJSONOut","ng-byte-draft-text"].includes(tgt.id) &&
        /quote|बाइट|actual/i.test((tgt.getAttribute("placeholder")||"") + " " + (tgt.getAttribute("name")||"") + " " + (tgt.id||""));

      if (!isQuoteCtl) return;

      const row = rowRootFrom(tgt);
      const d = extractRowData(row);
      if (!d.text) { toast(panel, "Quote खाली है"); return; }

      const { out, arr, wrap } = readBytesJSON();
      const next = Array.isArray(arr) ? arr.slice() : [];

      const entry = { speaker: d.speaker, designation: d.designation, text: d.text };
      const k = keyOf(entry);

      const exists = next.some(x => keyOf({speaker:x.speaker, designation:x.designation, text:(x.text||x.quote||x.value||"")}) === k);
      if (!exists){
        next.push(entry);
        writeBytesJSON(out, next, wrap);
        updateFinalBytesUI(panel, next);
        toast(panel, "Added ✓ (double-click)");
      } else {
        toast(panel, "Already added");
      }
    }, true);
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", () => setTimeout(boot, 900));
  } else {
    setTimeout(boot, 900);
  }
})();
/* NG_FINAL_BYTES_DBLCLICK_V11_END */
/* NG_FINAL_BYTES_DBLCLICK_V12_START */
;(() => {
  if (window.__NG_FINAL_BYTES_DBLCLICK_V12__) return;
  window.__NG_FINAL_BYTES_DBLCLICK_V12__ = true;

  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

  function readBytesJSON(){
    const out = document.getElementById("bytesJSONOut");
    if (!out) return { out:null, arr:[] };
    const raw = (out.value || "").trim();
    if (!raw) return { out, arr:[] };
    try{
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return { out, arr: parsed };
      if (parsed && Array.isArray(parsed.bytes)) return { out, arr: parsed.bytes, wrap:"bytes" };
      return { out, arr: [] };
    }catch(e){ return { out, arr: [] }; }
  }

  function writeBytesJSON(out, arr, wrap){
    if (!out) return;
    const payload = wrap === "bytes" ? { bytes: arr } : arr;
    out.value = JSON.stringify(payload, null, 2);
  }

  function keyOf(b){
    return [b.speaker||"", b.designation||"", b.text||""].join("||").trim();
  }

  function ensureFinalBytesList(){
    // Prefer existing V11 container if present
    let list = document.querySelector("#ng-final-bytes-list-v11") || document.querySelector("#ng-final-bytes-list-v12");
    if (!list){
      // attach into the first "Final Bytes" box we can find
      const box = qsa("div").find(d => /Final Bytes/i.test(d.innerText||"")) || document.body;
      list = document.createElement("div");
      list.id = "ng-final-bytes-list-v11"; // reuse v11 id to avoid duplicate UI blocks
      list.style.marginTop = "8px";
      list.style.display = "flex";
      list.style.flexDirection = "column";
      list.style.gap = "8px";
      box.appendChild(list);
    }
    return list;
  }

  function updateFinalBytesUI(arr){
    // Update header count
    const hdr = qsa("*").find(n => n.childElementCount===0 && /Final Bytes/i.test(n.textContent||""));
    if (hdr) hdr.textContent = "Final Bytes • " + arr.length;

    // Remove "(No bytes yet)" if present
    const empty = qsa("*").find(n => n.childElementCount===0 && /\(No bytes yet\)/i.test(n.textContent||""));
    if (empty && arr.length>0) empty.textContent = "";

    const list = ensureFinalBytesList();
    list.innerHTML = "";
    arr.slice(0,30).forEach(b => {
      const item = document.createElement("div");
      item.style.padding = "8px 10px";
      item.style.border = "1px solid #e5e7eb";
      item.style.borderRadius = "10px";
      item.style.fontSize = "13px";
      const who = [b.speaker||"", b.designation||""].filter(Boolean).join(" • ");
      const txt = (b.text||"").replace(/\s+/g," ").slice(0,220);
      item.textContent = (who ? (who + " — ") : "") + txt;
      list.appendChild(item);
    });
  }

  function toast(msg){
    let t = document.querySelector("#ng-toast-v11") || document.querySelector("#ng-toast-v12");
    if (!t){
      t = document.createElement("div");
      t.id = "ng-toast-v11"; // reuse v11 id
      t.style.position = "fixed";
      t.style.left = "14px";
      t.style.bottom = "14px";
      t.style.zIndex = "99999";
      t.style.padding = "6px 10px";
      t.style.borderRadius = "10px";
      t.style.background = "#111827";
      t.style.color = "white";
      t.style.fontSize = "12px";
      t.style.display = "none";
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.display = "inline-block";
    clearTimeout(t.__h);
    t.__h = setTimeout(() => { t.style.display = "none"; }, 900);
  }

  function boot(){
    const defQ = document.getElementById("ng-default-quote-template");
    if (!defQ) return;

    // Double-click on Default Quote (auto-fill) => add to Final Bytes
    defQ.addEventListener("dblclick", () => {
      const text = (defQ.value || "").trim();
      if (!text) { toast("Default Quote खाली है"); return; }

      // try reading defaults (if present)
      const bytesPanel = defQ.closest("div") || document.body;
      const speakerDefault = qsa("input", bytesPanel).find(i => /default speaker/i.test(i.placeholder||""))?.value?.trim() || "";
      const desigDefault  = qsa("input", bytesPanel).find(i => /default designation/i.test(i.placeholder||""))?.value?.trim() || "";

      const { out, arr, wrap } = readBytesJSON();
      const next = Array.isArray(arr) ? arr.slice() : [];

      const entry = { speaker: speakerDefault, designation: desigDefault, text };
      const k = keyOf(entry);
      const exists = next.some(x => keyOf({speaker:x.speaker, designation:x.designation, text:(x.text||x.quote||x.value||"")}) === k);

      if (!exists){
        next.push(entry);
        writeBytesJSON(out, next, wrap);
        updateFinalBytesUI(next);
        toast("Added ✓ (default quote)");
      } else {
        toast("Already added");
      }
    });
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", () => setTimeout(boot, 700));
  } else {
    setTimeout(boot, 700);
  }
})();
/* NG_FINAL_BYTES_DBLCLICK_V12_END */
/* NG_FINAL_BYTES_RENDER_V13_START */
;(() => {
  if (window.__NG_FINAL_BYTES_RENDER_V13__) return;
  window.__NG_FINAL_BYTES_RENDER_V13__ = true;

  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

  function readBytesJSON(){
    const out = document.getElementById("bytesJSONOut");
    if (!out) return [];
    const raw = (out.value || "").trim();
    if (!raw) return [];
    try{
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed;
      if (parsed && Array.isArray(parsed.bytes)) return parsed.bytes;
      return [];
    }catch(e){ return []; }
  }

  function findFinalBox(){
    // Find the node that literally contains "Final Bytes •"
    const leaf = qsa("*").find(n =>
      n.childElementCount===0 && /Final Bytes\s*•\s*\d+/i.test((n.textContent||"").trim())
    );
    if (!leaf) return null;

    // climb to a nice container (a bordered card-like div)
    let el = leaf;
    for (let i=0;i<10 && el;i++){
      const cs = getComputedStyle(el);
      const hasBorder = (cs.borderTopWidth !== "0px") || (cs.borderLeftWidth !== "0px");
      if (el.tagName==="DIV" && hasBorder) return el;
      el = el.parentElement;
    }
    return leaf.parentElement || null;
  }

  function ensureList(box){
    let list = box.querySelector("#ng-final-bytes-list-v13");
    if (!list){
      list = document.createElement("div");
      list.id = "ng-final-bytes-list-v13";
      list.style.marginTop = "8px";
      list.style.display = "flex";
      list.style.flexDirection = "column";
      list.style.gap = "8px";
      box.appendChild(list);
    }
    return list;
  }

  function render(){
    const box = findFinalBox();
    if (!box) return;

    const arr = readBytesJSON();

    // Update header count
    const hdr = qsa("*", box).find(n => n.childElementCount===0 && /Final Bytes/i.test(n.textContent||""));
    if (hdr) hdr.textContent = "Final Bytes • " + arr.length;

    // Remove "(No bytes yet)" if present
    const empty = qsa("*", box).find(n => n.childElementCount===0 && /\(No bytes yet\)/i.test(n.textContent||""));
    if (empty && arr.length>0) empty.textContent = "";

    const list = ensureList(box);
    list.innerHTML = "";
    arr.slice(0,30).forEach(b => {
      const item = document.createElement("div");
      item.style.padding = "8px 10px";
      item.style.border = "1px solid #e5e7eb";
      item.style.borderRadius = "10px";
      item.style.fontSize = "13px";
      const who = [b.speaker||"", b.designation||""].filter(Boolean).join(" • ");
      const txt = (b.text||"").replace(/\s+/g," ").slice(0,220);
      item.textContent = (who ? (who + " — ") : "") + txt;
      list.appendChild(item);
    });
  }

  // Re-render periodically for a short time after page load and after dblclicks
  function boot(){
    let n = 0;
    const t = setInterval(() => {
      render();
      n++;
      if (n > 10) clearInterval(t);
    }, 350);

    document.addEventListener("dblclick", () => {
      setTimeout(render, 120);
      setTimeout(render, 420);
    }, true);
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", () => setTimeout(boot, 500));
  } else {
    setTimeout(boot, 500);
  }
})();
/* NG_FINAL_BYTES_RENDER_V13_END */
/* NG_FINAL_BYTES_RENDER_V14_START */
;(() => {
  if (window.__NG_FINAL_BYTES_RENDER_V14__) return;
  window.__NG_FINAL_BYTES_RENDER_V14__ = true;

  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function findAddBtn(){
    return qsa("button").find(b => /\badd byte\b/i.test((b.textContent||"").trim()));
  }

  function findBytesPanel(addBtn){
    let el = addBtn;
    for (let i=0;i<18 && el;i++){
      const t = el.innerText || "";
      if (/\bBytes\b/i.test(t) && /Final Bytes/i.test(t)) return el;
      el = el.parentElement;
    }
    return addBtn.parentElement || document.body;
  }

  function readBytesArr(){
    const out = document.getElementById("bytesJSONOut");
    if (!out) return [];
    const raw = (out.value||"").trim();
    if (!raw) return [];
    try{
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed;
      if (parsed && Array.isArray(parsed.bytes)) return parsed.bytes;
      return [];
    }catch(e){ return []; }
  }

  function findFinalBox(bytesPanel){
    // ONLY inside Bytes panel, ignore script/style
    const nodes = qsa("div,section,details", bytesPanel)
      .filter(n => n.tagName !== "SCRIPT" && n.tagName !== "STYLE")
      .filter(n => /Final Bytes/i.test(n.innerText||""));

    // Prefer the smallest node that contains "Final Bytes" text
    const box = nodes.sort((a,b)=> (a.innerText||"").length - (b.innerText||"").length)[0] || null;

    // Climb to a bordered container if needed
    let el = box;
    for (let i=0;i<8 && el;i++){
      const cs = getComputedStyle(el);
      const hasBorder = (cs.borderTopWidth !== "0px") || (cs.borderLeftWidth !== "0px");
      if (el.tagName==="DIV" && hasBorder) return el;
      el = el.parentElement;
    }
    return box;
  }

  function ensureList(finalBox){
    let list = finalBox.querySelector("#ng-final-bytes-list-v14");
    if (!list){
      list = document.createElement("div");
      list.id = "ng-final-bytes-list-v14";
      list.style.marginTop = "8px";
      list.style.display = "flex";
      list.style.flexDirection = "column";
      list.style.gap = "8px";
      finalBox.appendChild(list);
    }
    return list;
  }

  function renderOnce(){
    const addBtn = findAddBtn();
    if (!addBtn) return {ok:false, err:"no addBtn"};

    const bytesPanel = findBytesPanel(addBtn);
    const finalBox = findFinalBox(bytesPanel);
    if (!finalBox) return {ok:false, err:"no finalBox"};

    const arr = readBytesArr();

    // Update header count inside finalBox
    const hdr = qsa("*", finalBox)
      .find(n => n.childElementCount===0 && /Final Bytes/i.test((n.textContent||"")));
    if (hdr) hdr.textContent = "Final Bytes • " + arr.length;

    // Clear "(No bytes yet)" line
    const empty = qsa("*", finalBox)
      .find(n => n.childElementCount===0 && /\(No bytes yet\)/i.test((n.textContent||"")));
    if (empty && arr.length>0) empty.textContent = "";

    const list = ensureList(finalBox);
    list.innerHTML = "";
    arr.slice(0,30).forEach(b => {
      const item = document.createElement("div");
      item.style.padding = "8px 10px";
      item.style.border = "1px solid #e5e7eb";
      item.style.borderRadius = "10px";
      item.style.fontSize = "13px";
      const who = [b.speaker||"", b.designation||""].filter(Boolean).join(" • ");
      const txt = (b.text||"").replace(/\s+/g," ").slice(0,220);
      item.textContent = (who ? (who + " — ") : "") + txt;
      list.appendChild(item);
    });

    return {ok:true, count: arr.length};
  }

  async function boot(){
    // multiple attempts because UI builds late
    for (let i=0;i<10;i++){
      const r = renderOnce();
      if (r && r.ok) break;
      await sleep(300);
    }

    // After any dblclick (your add-to-final action), re-render
    document.addEventListener("dblclick", () => {
      setTimeout(renderOnce, 120);
      setTimeout(renderOnce, 420);
    }, true);
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", () => setTimeout(boot, 500));
  } else {
    setTimeout(boot, 500);
  }
})();
/* NG_FINAL_BYTES_RENDER_V14_END */
/* NG_FINAL_BYTES_WIRE_V14A_START */
(function () {
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  function getOutEl(){
    return document.getElementById("bytesJSONOut");
  }

  function safeParseBytes(jsonText){
    if(!jsonText) return null;
    try{
      const j = JSON.parse(jsonText);
      if (Array.isArray(j)) return j;
      if (j && Array.isArray(j.bytes)) return j.bytes;
      return null;
    }catch(e){ return null; }
  }

  function ensureState(){
    if (!window.__NG_FINAL_BYTES_STATE__) {
      const out = getOutEl();
      const existing = out ? safeParseBytes(out.value) : null;
      window.__NG_FINAL_BYTES_STATE__ = { bytes: Array.isArray(existing) ? existing : [] };
    }
    return window.__NG_FINAL_BYTES_STATE__;
  }

  function writeOut(bytes){
    const out = getOutEl();
    if(!out) return;
    out.value = JSON.stringify(bytes, null, 2);
    out.dispatchEvent(new Event("input", { bubbles:true }));
    out.dispatchEvent(new Event("change", { bubbles:true }));
  }

  function normalizeStr(s){ return (s||"").toString().trim(); }

  function extractByteFromEvent(ev){
    const t = ev && ev.target ? ev.target : null;
    if(!t) return null;

    // row/container guess (as tolerant as possible)
    const row = t.closest(".row, .ng-row, [data-byte-row], [data-ng-byte-row], #bytesWrap .row, #bytesWrapInner .row") || t.parentElement;
    const root = row || document;

    const speaker =
      normalizeStr( ( $("input[name='speaker']", root) || $("input[data-role='speaker']", root) || $("input[placeholder*='Speaker']", root) || $("input[placeholder*='स्पीकर']", root) )?.value );

    const designation =
      normalizeStr( ( $("input[name='designation']", root) || $("input[data-role='designation']", root) || $("input[placeholder*='Designation']", root) || $("input[placeholder*='पद']", root) )?.value );

    // quote: textarea OR input OR contenteditable
    let text =
      normalizeStr( ( $("textarea[name='quote']", root) || $("textarea[data-role='quote']", root) || $("textarea", root) )?.value );

    if(!text){
      text = normalizeStr( ( $("input[name='quote']", root) || $("input[data-role='quote']", root) )?.value );
    }
    if(!text && t.isContentEditable){
      text = normalizeStr(t.innerText);
    }
    if(!text && row){
      // fallback: last textarea in row
      const tas = $all("textarea", row);
      if(tas.length) text = normalizeStr(tas[tas.length-1].value);
    }

    if(!text) return null;
    return { speaker, designation, text };
  }

  function dedupePush(bytes, b){
    const key = (x)=>[normalizeStr(x.speaker), normalizeStr(x.designation), normalizeStr(x.text)].join("||");
    const k = key(b);
    if (!k || k === "||||") return bytes;
    const exists = bytes.some(x => key(x) === k);
    if(!exists) bytes.push(b);
    return bytes;
  }

  function renderNow(){
    const r = window.__NG_FINAL_BYTES_RENDER_V14__;
    if (typeof r === "function") {
      try { r(); return true; } catch(e1){}
      try { r(ensureState().bytes); return true; } catch(e2){}
    }
    return false;
  }

  // Wrap dblclick handlers (V11/V12) so AFTER dblclick we sync -> bytesJSONOut and render
  function wrap(name){
    const fn = window[name];
    if (typeof fn !== "function" || fn.__ng_wrapped_v14a__) return;

    const wrapped = function(...args){
      const ev = args && args[0] && args[0].target ? args[0] : null;
      let ret;
      try { ret = fn.apply(this, args); } catch(e){ ret = undefined; }

      try{
        const st = ensureState();
        const b = ev ? extractByteFromEvent(ev) : null;
        if (b) {
          st.bytes = dedupePush(Array.isArray(st.bytes)?st.bytes:[], b);
          writeOut(st.bytes);
        } else {
          // even if we couldn't extract, still try to render from existing state/out
          const out = getOutEl();
          const existing = out ? safeParseBytes(out.value) : null;
          if (existing && Array.isArray(existing)) {
            st.bytes = existing;
          }
        }
        renderNow();
      } catch(e) {}

      return ret;
    };

    wrapped.__ng_wrapped_v14a__ = true;
    window[name] = wrapped;
  }

  wrap("__NG_FINAL_BYTES_DBLCLICK_V11__");
  wrap("__NG_FINAL_BYTES_DBLCLICK_V12__");

  // Also: if state already exists, try an initial render
  try { ensureState(); renderNow(); } catch(e) {}
})();
 /* NG_FINAL_BYTES_WIRE_V14A_END */
/* NG_DEFAULT_QUOTE_PSEUDO_DBLCLICK_TO_FINAL_V1_START */
(function () {
  const QUOTE_ID = "ng-default-quote-template";
  const DBL_MS = 420;

  function norm(s){ return (s||"").toString().trim(); }

  function getOutEl(){ return document.getElementById("bytesJSONOut"); }

  function ensureState(){
    if (!window.__NG_FINAL_BYTES_STATE__) window.__NG_FINAL_BYTES_STATE__ = { bytes: [] };
    if (!Array.isArray(window.__NG_FINAL_BYTES_STATE__.bytes)) window.__NG_FINAL_BYTES_STATE__.bytes = [];
    return window.__NG_FINAL_BYTES_STATE__;
  }

  function writeOut(bytes){
    const out = getOutEl();
    if(!out) return;
    out.value = JSON.stringify(bytes, null, 2);
    out.dispatchEvent(new Event("input", { bubbles:true }));
    out.dispatchEvent(new Event("change", { bubbles:true }));
  }

  function renderNow(){
    const r = window.__NG_FINAL_BYTES_RENDER_V14__;
    if (typeof r === "function") {
      try { r(); return true; } catch(e1){}
      try { r(ensureState().bytes); return true; } catch(e2){}
    }
    return false;
  }

  function findSpeakerDesignation(quoteEl){
    // try within same panel first
    const root = quoteEl.closest("details, section, div") || document;

    const inputs = Array.from(root.querySelectorAll("input"));
    const speakerEl = inputs.find(i => /speaker|स्पीकर/i.test(i.placeholder||"") || /speaker/i.test(i.name||"") || i.id==="ng-default-speaker");
    const desigEl  = inputs.find(i => /designation|पद|designation\/title/i.test(i.placeholder||"") || /designation/i.test(i.name||"") || i.id==="ng-default-designation");

    const speaker = norm(speakerEl ? speakerEl.value : "");
    const designation = norm(desigEl ? desigEl.value : "");

    return { speaker, designation };
  }

  function dedupePush(bytes, b){
    const key = (x)=>[norm(x.speaker), norm(x.designation), norm(x.text)].join("||");
    const k = key(b);
    if(!k || k==="||||") return bytes;
    if(!bytes.some(x => key(x) === k)) bytes.push(b);
    return bytes;
  }

  function install(){
    const quoteEl = document.getElementById(QUOTE_ID);
    if(!quoteEl) return { ok:false, err:"QUOTE_NOT_FOUND", id: QUOTE_ID };

    // pseudo dblclick via click timing
    let lastT = 0;
    let lastTarget = null;

    quoteEl.addEventListener("click", (ev) => {
      const now = Date.now();
      const isDouble = (lastTarget === ev.target) && ((now - lastT) <= DBL_MS);
      lastT = now; lastTarget = ev.target;

      if(!isDouble) return; // only act on pseudo dblclick

      const text = norm(quoteEl.value);
      if(!text) return;

      const { speaker, designation } = findSpeakerDesignation(quoteEl);
      const st = ensureState();

      dedupePush(st.bytes, { speaker, designation, text });
      writeOut(st.bytes);
      renderNow();

      console.log("[NG] Added default quote to Final Bytes:", { speaker, designation, textHead: text.slice(0,60), count: st.bytes.length });
    }, true);

    return { ok:true, installed:true, id: QUOTE_ID, dblMs: DBL_MS };
  }

  // delayed install (in case DOM loads late)
  const t0 = Date.now();
  const timer = setInterval(() => {
    const res = install();
    if (res.ok || (Date.now()-t0)>6000) {
      clearInterval(timer);
      if(!res.ok) console.warn("[NG] default quote hook failed:", res);
      else console.log("[NG] default quote hook installed:", res);
    }
  }, 250);
})();
 /* NG_DEFAULT_QUOTE_PSEUDO_DBLCLICK_TO_FINAL_V1_END */

/* NG_FINAL_BYTES_RENDER_FALLBACK_V14B_START */
(function(){
  function norm(s){ return (s||"").toString().trim(); }

  function getOut(){
    return document.getElementById("bytesJSONOut");
  }

  function readBytes(){
    const out = getOut();
    const txt = out ? (out.value || "") : "";
    if(!txt) return [];
    try{
      const j = JSON.parse(txt);
      if(Array.isArray(j)) return j;
      if(j && Array.isArray(j.bytes)) return j.bytes;
      return [];
    }catch(e){
      return [];
    }
  }

  function findFinalPanel(){
    const nodes = Array.from(document.querySelectorAll("div,section,details"))
      .filter(n => /Final Bytes/i.test(n.innerText || ""));
    // prefer the one that has "(No bytes yet)" / "Final Bytes •"
    const scored = nodes.map(n => {
      const t = (n.innerText||"");
      let s = 0;
      if(/Final Bytes\s*•/i.test(t)) s += 3;
      if(/\(No bytes yet\)/i.test(t)) s += 2;
      if(/\bAdd\b/i.test(t) && /\bByte\b/i.test(t)) s += 1;
      return {n, s};
    }).sort((a,b)=>b.s-a.s);
    return scored[0] ? scored[0].n : (nodes[0] || null);
  }

  function ensureListHost(panel){
    if(!panel) return null;

    let host =
      panel.querySelector("#ng-final-bytes-list-auto") ||
      panel.querySelector("#ng-final-bytes-list") ||
      panel.querySelector("[data-role='final-bytes-list']");

    if(!host){
      host = document.createElement("div");
      host.id = "ng-final-bytes-list-auto";
      host.style.marginTop = "10px";
      host.style.display = "flex";
      host.style.flexDirection = "column";
      host.style.gap = "8px";
      panel.appendChild(host);
    }
    return host;
  }

  function updateCountAndEmpty(panel, count){
  if(!panel) return;

  // Update "Final Bytes • X" line (best-effort)
  const candidates = Array.from(panel.querySelectorAll("*"))
    .filter(el => /Final Bytes\s*•/i.test(el.innerText||""))
    .slice(0,5);

  if(candidates[0]){
    candidates[0].innerText = `Final Bytes • ${count}`;
  }

  // SAFE hide: सिर्फ वही element hide करो जिसकी text EXACT "(No bytes yet)" हो
  if(count > 0){
    const empties = Array.from(panel.querySelectorAll("*")).filter(el => {
      const txt = (el.innerText || "").trim();
      return txt === "(No bytes yet)";
    });
    empties.forEach(el => { el.style.display = "none"; });
  }
}

    // Hide "(No bytes yet)" if count > 0
    if(count > 0){
      const empties = Array.from(panel.querySelectorAll("*"))
        .filter(el => /\(No bytes yet\)/i.test(el.innerText||""));
      empties.forEach(el => { el.style.display = "none"; });
    }
  }

  function renderCards(host, bytes){
    host.innerHTML = "";
    bytes.forEach((b, idx) => {
      const card = document.createElement("div");
      card.style.border = "1px solid #e5e7eb";
      card.style.borderRadius = "12px";
      card.style.padding = "10px";
      card.style.background = "#fff";

      const top = document.createElement("div");
      top.style.fontSize = "12px";
      top.style.opacity = "0.75";
      top.style.marginBottom = "6px";
      const who = [norm(b.speaker), norm(b.designation)].filter(Boolean).join(" • ");
      top.textContent = who ? `#${idx+1}  ${who}` : `#${idx+1}`;
      card.appendChild(top);

      const q = document.createElement("div");
      q.style.whiteSpace = "pre-wrap";
      q.style.fontSize = "14px";
      q.textContent = norm(b.text);
      card.appendChild(q);

      host.appendChild(card);
    });
  }

  // Define/force global renderer if missing
  if (typeof window.__NG_FINAL_BYTES_RENDER_V14__ !== "function") {
    window.__NG_FINAL_BYTES_RENDER_V14__ = function(){
      const bytes = readBytes();
      const panel = findFinalPanel();
      const host = ensureListHost(panel);
      if(host) renderCards(host, bytes);
      updateCountAndEmpty(panel, bytes.length);
      return { ok:true, count: bytes.length, hostId: host ? host.id : null };
    };
  }

  // Auto-render on bytesJSONOut input/change
  const out = getOut();
  if(out && !out.__ng_v14b_bound__){
    out.__ng_v14b_bound__ = true;
    out.addEventListener("input", () => { try{ window.__NG_FINAL_BYTES_RENDER_V14__(); }catch(e){} }, true);
    out.addEventListener("change", () => { try{ window.__NG_FINAL_BYTES_RENDER_V14__(); }catch(e){} }, true);
  }

  // Initial render
  try{ window.__NG_FINAL_BYTES_RENDER_V14__(); }catch(e){}
})();
 /* NG_FINAL_BYTES_RENDER_FALLBACK_V14B_END */


